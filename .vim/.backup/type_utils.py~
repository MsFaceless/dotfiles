# -*- coding: utf-8 -*-
from sqlalchemy.orm import session  # temp, delete this
from rocket import model

class RawTypeDictionary:
    def __init__(self):
        self.__list_of_type_dicts = [
            # """Product Types"""
            {
                "product_life_assured_sum_assured_type": {"percentage", "amount"},
                "product_life_assured_relationship_type": {"principal", "spouse"},
                "product_life_assured_type": {"member_only", "member_and_family", "family_only"},
                "product_purchase_type": {"group", "coupon", "loyalty"},
                "product_price_initial_setup_type": {"fixed_price", "fixed_sum_assured"},
                "product_type": {"voucher", "traditional", "term_life", "credit_life"},
                "product_state_type": {"sandbox", "active", "expired"},
                "loader_question_premium_effect_type": {"none", "percentage", "amount"},
                "product_allocation_type": {"acquisition", "purchase"},
                "product_allocation_calculation_type": {"percentage", "amount", "factor"},
                "product_benefit_allocation_type": {"claim", "redemption", "refund"},
                "product_message_type": {"reminder", "claim", "confirmation", "contract"},
                "product_communication_type": {"sms", "email", "print"},
                "product_cover_and_exclusion_type": {"life_all_causes", "natural", "accidental", "suicide", "act_of_god"},
                "product_benefit_exclusion_expiry_type": {"number_of_days", "number_of_premiums", "infinite"},
                "product_benefit_type": {"main_benefit", "additional_benefit", "rider"},
                "product_benefit_effect_on_sum_assured_type": {"increases", "decreases", "no_change"},
                "product_benefit_effect_on_price_type": {"increases", "no_change"},
                "product_benefit_share_of_price_type": {"amount", "percentage", "none"},
                "product_benefit_share_of_sum_assured_type": {"percentage", "stated_benefit", "amount", "none"},
                "product_period_type": {"days", "months", "calendar_months", "years"},
                "product_period_effect_type": {"active", "waiting", "claim_grace", "refund_grace"},
                "product_frequency_type": {"single", "daily", "monthly", "semi_annually", "annually"},
            },

            # """Policy Types"""
            {
                "policy_type": {"group", "individual"},
                "policy_state_type":
                    {"proposal", "not_taken_up", "policy", "surrendered", "matured", "claimed", "lapsed"},
                "policy_premium_payment_method_type":
                    {"debit_order", "eft", "cash", "postal_order", "money_transfer"},
                "policy_date_type": {"proposal", "accepted", "policy", "valid_from", "valid_to", "surrender", "maturatity"},
            },

            # """Transaction Types"""
            {
                "payment_type": {"debit_order", "eft", "cash", "postal_order", "money_transfer"},
                "payment_transaction_type": {},
                "payment_transaction_debit_credit_type": {},
            },

            # """Entity Types"""
            {
                "entity_type": {"person", "organisation"},
                "entity_organisation_type": {"company", "trust", "independent_agent"},
                "organisation_contact_type": {"office", "email"},
            },

            # """ Claim Types """
            {
                "claim_status_type": {"newly_registered", "rejected", "suspended", "ready_for_approval", "approved",
                                      "adjudicated", "reopened", "completed"},
                "claim_payout_allocation_type": {},
            },

            # """Batch Import Types"""
            {
                "batch_import_type": {"default"},
            },

            # """ System Document Types
            {
                "system_document_type": {"claim", "member", "product"}
            }
        ]
        self.raw_dictionary_of_types = self.__create_raw_dict_of_types()

    def __create_raw_dict_of_types(self):
        dict_types = {}
        for dictionary in self.__list_of_type_dicts:
            dict_types.update(dictionary)
        return dict_types


raw_type_dictionary = RawTypeDictionary().raw_dictionary_of_types


class TypeDictionary:
    def __init__(self):
        self.list_of_types = list(raw_type_dictionary)
        self.type_dictionary = self.__create_type_dictionary_from_database()

    def __create_type_dictionary_from_database(self):
        type_dict = {}
        for i in self.list_of_types:
            type_class = i.title().replace("_", "")
            type_dict.update({i: {i.id: i.name for i in getattr(model, type_class).get_all('name')}})
        return type_dict

    def get_id_of_name(self, type_table_name: str, type_name: str):
        sub_dict = self.type_dictionary.get(type_table_name)
        if not sub_dict:
            print(f"\n > get_id_of_name: No such type found: {type_table_name} < \n")
            return None
        for key, value in sub_dict.items():
            if value == type_name:
                return key
        print(f"\n > get_id_of_name: No such name found: {type_table_name} - {type_name} < \n")
        return None

    def get_pretty_name(self, type_table_name: str, type_id: int):
        sub_dict = self.type_dictionary.get(type_table_name)
        if not sub_dict:
            print(f"\n > get_pretty_name: No such type found: {type_table_name} < \n")
            return None
        for key, value in sub_dict.items():
            if key == type_id:
                return value.title().replace("_", " ")
        print(f"\n > get_pretty_name: No such id found: {type_table_name} - {type_id} < \n")
        return None

    def get_name(self, type_table_name: str, type_id: int):
        sub_dict = self.type_dictionary.get(type_table_name)
        if not sub_dict:
            print(f"\n > get_name: No such type found: {type_table_name} < \n")
            return None
        for key, value in sub_dict.items():
            if key == int(type_id):
                return value
        print(f"\n > get_name: No such id found: {type_table_name} - {type_id} < \n")
        return None

    def get_dict_of_types(self, type_table_name: str):
        sub_dict = self.type_dictionary.get(type_table_name)
        if not sub_dict:
            print(f"\n > get_dict_of_types: No such type found: {type_table_name} < \n")
            return None
        return sub_dict
