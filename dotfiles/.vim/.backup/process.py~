"""Bank controller module"""
import urllib.parse
from tg.predicates import has_permission

from tg.i18n import ugettext as _, lazy_ugettext as l_
import string
import datetime

from sqlalchemy import func, desc, asc, and_, or_
from tg import expose, require, redirect, validate, flash, url, request, response, predicates

from tanzanite.model import *

from tanzanite.lib.tg_utils import *
from tanzanite.lib.base import BaseController
from tanzanite.lib.email_creator import EmailCreator

from tanzanite.controllers.card import CardController
from tanzanite.controllers.operational import OperationalController
from tanzanite.controllers.client_order import ClientOrderController
from tanzanite.controllers.common import CommonController
from tanzanite.controllers.logging import LoggingController

LOGGING = LoggingController()
CARD = CardController()
OPERATIONAL = OperationalController()
CLIENT_ORDER = ClientOrderController()
COMMON = CommonController()

# This is basically the Processes and Timers that live here. Should be above the othger controllers.

class ProcessController(BaseController):

    allow_only = has_permission(
        'Operator',
        msg=l_('Only for people with the "Operator" permission')
    )
    def notify_low_stock_level(self, *args, **kwargs):
        #TGJ: Tested 20200213
        flag = False
        product_list = DBSession.query(Product, Client).\
            filter(Product.client_id == Client.id).\
            all()
        print('TGJ: Todo: Make this report on BULK stores too.')
        for product, client in product_list:
            result = self.get_product_stock_level(**{'product_id': product.id})
            total_available = json.loads(result).get('total_available')
            # available_bulk = json.loads(result).get('available_bulk')
            if total_available <= product.reorder_quantity:
                flag = True
                break

        if not flag: return

        print('################################################################################')
        print('Camilla: Branch Low Stock Notification.')
        print('Camilla: Wareouhse Low Stock Notification.')
        print('Send mail to all administrators')
        print('################################################################################')

        return

    def return_stock_from_branches(self, *args, **kwargs):
        #TGJ: Tested 20200213
        branch_list = DBSession.query(ClientBranch).\
            filter(ClientBranch.is_active == False).\
            all()

        for branch in branch_list:
            OPERATIONAL.return_branch_stock(**{
                'client_branch_id': branch.id
                })

        self.update_soh(**{
            'delete_first': False ,
            'start_reorder': False , })
        return

    def check_branch_level(self, *args, **kwargs):
        #TGJ: Tested 20200213
        print('Start Checking stock levels')
        batch_import_id = kwargs.get('batch_import_id', None)
        if not batch_import_id: return json.dumps({'success': 'false', })

        batch_import = BatchImport.by_id(batch_import_id)
        if not batch_import: return json.dumps({'success': 'false', })

        # if not batch_import.is_complete_update:
        #     return json.dumps({'success': 'true', })

        client_list = DBSession.query(Client).all()
        if not client_list: return json.dumps({'success': 'false', })

        managed_id = COMMON.get_type_id(StockManagementType, 'Managed')
        automatic_id = COMMON.get_type_id(OrderingMethod, 'Automatic')
        received_id = COMMON.get_type_id(ClientOrderStatus, 'Received')
        cancelled_id = COMMON.get_type_id(ClientOrderStatus, 'Cancelled')
        created_id = COMMON.get_type_id(ClientOrderStatus, 'Created')
        usernow = request.identity.get('user', {})
        is_created_order = False

        for client in client_list:
            #Get the branches for this client that pass the filterd
            branch_list = DBSession.query(ClientBranch). \
                filter(ClientBranch.stock_management_type_id == managed_id). \
                filter(ClientBranch.ordering_method_id == automatic_id). \
                filter(ClientBranch.client_id==client.id). \
                filter(ClientBranch.is_active==True). \
                order_by(ClientBranch.store_number). \
                all()
            if not branch_list: continue

            client_id = client.id
            new_client_order_batch_id = None
            created_date = None
            created_by_id = None
            new_client_order_id = None

            for branch in branch_list:
                new_client_order_id = None
                #Chedck if I need to order for this branch
                store, store_location = DBSession.query(Store, StoreLocation).\
                    filter(StoreLocation.store_id==Store.id).\
                    filter(Store.client_branch_id==branch.id).\
                    first()
                if not store_location: continue

                branch_products = DBSession.query(ClientBranchProduct).\
                    filter(ClientBranchProduct.client_branch_id==branch.id).\
                    order_by(ClientBranchProduct.product_id).\
                    all()
                if not branch_products: continue

                for branch_product in branch_products:
                    store_level = DBSession.query(ProductStoreLevel).\
                        filter(and_((ProductStoreLevel.product_id == branch_product.product_id), \
                                    (ProductStoreLevel.store_location_id == store_location.id))).\
                        filter(ProductStoreLevel.quantity <= branch_product.min_re_order). \
                        first()
                    if not store_level: continue
                    # # Mkae sure this is not already on order
                    # found = DBSession.query(ClientOrder.Id). \
                    #     join(ClientOrderDetail, ClientOrderDetail.client_order_id == ClientOrder.id).\
                    #     filter(ClientOrder.client_branch_id == branch.id). \
                    #     filter(and_((ClientOrder.client_order_status_id != received_id), \
                    #         (ClientOrder.client_order_status_id != cancelled_id))). \
                    #     filter(ClientOrderDetail.product_id == branch_product.product_id). \
                    #     filter(ClientOrderDetail.filled == 0). \
                    #     first()

                    # if not found: continue
                    if not new_client_order_batch_id:
                        this = ClientOrderBatch()
                        this.client_id = client_id
                        this.client_order_batch_status_id = COMMON.get_type_id(ClientOrderBatchStatus, 'Created')
                        this.ordering_method_id = branch.ordering_method_id
                        this.created = datetime.now()
                        this.created_by_id = usernow.id
                        DBSession.add(this)
                        DBSession.flush()

                        is_created_order = True
                        new_client_order_batch_id = this.id
                        created_date = this.created
                        created_by_id = this.created_by_id

                    if not new_client_order_id:
                        #For each Branch
                        this = ClientOrder()
                        this.order_number = COMMON.generate_order_number(**{'client_branch_id': branch.id})
                        this.client_order_batch_id = new_client_order_batch_id
                        this.client_branch_id = branch.id
                        this.client_order_status_id = created_id
                        this.delivery_method_id = branch.default_delivery_method_id
                        this.shipping_box_count = 1
                        this.created = created_date
                        this.created_by_id = usernow.id
                        DBSession.add(this)
                        DBSession.flush()

                        new_client_order_id = this.id

                    product = Product.by_id(branch_product.product_id)
                    order_quantity = branch_product.standard_order

                    if product.client_reorder_type_id == product.level_1_type_id:
                        order_quantity = branch_product.standard_order
                    elif product.client_reorder_type_id == product.level_2_type_id:
                        order_quantity = branch_product.standard_order / product.level_2_quantity
                    else: #product.client_reorder_type_id == product.level_3_type_id:
                        order_quantity = branch_product.standard_order / (product.level_2_quantity * product.level_3_quantity)

                    #Create the detail here.
                    this = ClientOrderDetail()
                    this.client_order_id = new_client_order_id
                    this.product_id = product.id
                    this.order_quantity = order_quantity
                    this.reorder_type_id = product.client_reorder_type_id
                    this.ordered = datetime.now()
                    this.ordered_by = usernow.id
                    DBSession.add(this)
                    DBSession.flush()

            # if is_created_order:
            #     adminrole = Role.by_name('Administrator')
            #     for admin in adminrole.users:
            #         if not admin.email: continue
            #         e = EmailCreator()
            #         e.add_subject('Tanzanite - Automatic Client Branch Order Creation Notification')
            #         e.add_to_address(admin.email)
            #         plain_text = f"""
            #         Hi {admin.name},
            #
            #         An automated order batch has been created.
            #         Please review and complete as needed.
            #
            #         Kind regards,
            #         The Tanzanite Team
            #         """
            #         e.add_plain_text(plain_text)
            #
            #         rich_text = f"""
            #         <html>
            #             Hi {admin.name},
            #
            #             An automated order batch has been created.
            #             Please review and complete as needed.
            #
            #             Kind regards,
            #             The Tanzanite Team
            #         </html>
            #         """
            #         e.add_rich_text(rich_text)
            #         e.send(verbose=False)

            #TGJ: Todo: This should be an asynchronous call to this function.
            print('Start Auto Process')
            self.process_auto_orders(**{'client_order_batch_id': new_client_order_batch_id})
        print('Completed checking stock levels')
        return json.dumps({'success': 'true', })

    def process_auto_orders(self, *args, **kwargs):
        #Automatically processes the order henerated as a result of a daily sales file import.
        print('Started Process Order:', kwargs)
        client_order_batch_id = kwargs.get('client_order_batch_id', None)
        if not client_order_batch_id:
            adminrole = Role.by_name('Administrator')
            for admin in adminrole.users:
                if not admin.email: continue
                e = EmailCreator()
                e.add_subject('Tanzanite - Automatic Client Branch Order Creation Notification')
                e.add_to_address(admin.email)
                plain_text = f"""
                Hi {admin.name},

                There were no Client Branches with low stock levels that require an automated order to be created.

                Kind regards,
                The Tanzanite Team
                """
                e.add_plain_text(plain_text)

                rich_text = f"""
                <html>
                    <div>
                    <p>
                    Hi {admin.name},
                    <p> </p>
                    <p> </p>
                    <p>
                    There were no Client Branches with low stock levels that require an automated order to be created.
                    </p>
                    <p> </p>
                    <p> </p>
                    <p>
                    Kind regards,
                    </p>
                    <p> </p>
                    <p>
                    The Tanzanite Team
                    </p>
                    </div>
                </html>
                """
                e.add_rich_text(rich_text)
                e.send(verbose=False)
            return

        enough_stock = self.enough_stock_in_cage(client_order_batch_id)
        if not enough_stock:
            adminrole = Role.by_name('Administrator')
            for admin in adminrole.users:
                if not admin.email: continue
                e = EmailCreator()
                e.add_subject('Tanzanite - Automatic Client Branch Order Failure Notification')
                e.add_to_address(admin.email)
                plain_text = f"""
                Hi {admin.name},

                An automated order batch has been created, but the system was
                unable to automatically process this batch as a result of
                insufficient cage stock.
                Please review and complete as needed.

                Kind regards,
                The Tanzanite Team
                """
                e.add_plain_text(plain_text)

                rich_text = f"""
                <html>
                    <div>
                    <p>
                    Hi {admin.name},
                    </p>
                    <p> </p>
                    <p> </p>
                    <p>
                    An automated order batch has been created, but the system was
                    unable to automatically process this batch as a result of
                    insufficient cage stock.
                    </p>
                    <p>
                    Please review and complete as needed.
                    </p>
                    <p> </p>
                    <p>
                    Kind regards,
                    </p>
                    <p> </p>
                    <p>
                    The Tanzanite Team
                    </p>
                    </div>
                </html>
                """
                e.add_rich_text(rich_text)
                e.send(verbose=False)
            return False

        #Process the order.
        usernow = request.identity.get('user', {})
        client_order_batch = ClientOrderBatch.by_id(client_order_batch_id)
        client = Client.by_id(client_order_batch.client_id)
        filled_id = COMMON.get_type_id(ClientOrderStatus, 'Filled')

        #Look only for unfilled orders.
        client_order_list = DBSession.query(ClientOrder.id, ClientBranch.store_number).\
            filter(ClientBranch.id == ClientOrder.client_branch_id).\
            filter(ClientOrder.client_order_batch_id == client_order_batch_id).\
            filter(ClientOrder.client_order_status_id != filled_id).\
            order_by(ClientBranch.store_number).\
            all()
        if not client_order_list:
            print('No orders to Fill:')
            return True
        for order_id, store_number in client_order_list:
            # Only unfilled items.
            order_detail_list = DBSession.query(ClientOrderDetail).\
                filter(ClientOrderDetail.client_order_id == order_id).\
                filter(ClientOrderDetail.filled_quantity <= 0).\
                all()

            for item in order_detail_list:
                print('Cient Order Detail: ', item.order_quantity, item.filled_quantity)
                item.filled_quantity = item.order_quantity
                item.filled = datetime.now()
                item.filled_by_id = usernow.id
                # DBSession.flush()
                #Allocate the correct sleeves.
                CLIENT_ORDER.pick_product_fifo(item.id, item.product_id, item.filled_quantity)

            order = ClientOrder.by_id(order_id)
            order.client_order_status_id = filled_id
            DBSession.flush()

            #write the history
            OPERATIONAL.write_client_order_history(order.id, order.client_order_status_id)

        #update the batch
        client_order_batch.client_order_batch_status_id = COMMON.get_type_id(ClientOrderBatchStatus, 'InProcess')
        DBSession.flush()

        OPERATIONAL.write_client_order_batch_history(client_order_batch_id, client_order_batch.client_order_batch_status_id)

        adminrole = Role.by_name('Administrator')
        for admin in adminrole.users:
            if not admin.email: continue
            e = EmailCreator()
            e.add_subject('Tanzanite - Automatic Client Branch Order Creation Notification')
            e.add_to_address(admin.email)
            plain_text = f"""
            Hi {admin.name},

            An automated order batch for {client.name} has been created.

            Please review and complete as needed

            Kind regards,
            The Tanzanite Team
            """
            e.add_plain_text(plain_text)

            rich_text = f"""
            <html>
                <div>
                <p>
                    Hi {admin.name},
                </p>
                <p>
                    An automated order batch for {client.name} has been created.
                </p>
                <p>
                    Please review and complete as needed
                <p>
                </p>
                <p>
                    Kind regards,
                </p>
                <p> </p>
                <p>
                    The Tanzanite Team
                </p>
                </div>
            </html>
            """


            e.add_rich_text(rich_text)
            e.send(verbose=False)
        return True

    def enough_stock_in_cage(self, client_order_batch_id=None, *args, **kwargs):
        if not client_order_batch_id: return False
        #Sum the total number of refill qty for each product in this order and see if there is nough stock in Cage...
        dbase_query = DBSession.query(
                        ClientOrderDetail.product_id,
                        func.sum(ClientOrderDetail.order_quantity),
                ). \
            join(ClientOrder, ClientOrder.id == ClientOrderDetail.client_order_id).\
            filter(ClientOrder.client_order_batch_id == client_order_batch_id).\
            group_by(ClientOrderDetail.product_id).\
            order_by(ClientOrderDetail.product_id).\
            all()
        if not dbase_query: return False

        cage_store_id = COMMON.get_cage_store_id()

        for product_id, order_count in dbase_query:
            product = Product.by_id(product_id)
            available = CLIENT_ORDER.get_available_packs(product_id, cage_store_id, product.client_reorder_type_id)
            if available < order_count: return False

        return True

    def ship_order_batch(self, *args, **kwargs):
        client_order_batch_id = kwargs.get('client_order_batch_id', None)
        print(' Client Order Batch:', client_order_batch_id)
        if not client_order_batch_id: return json.dumps({'success': 'false', })

        client_order_batch = ClientOrderBatch.by_id(client_order_batch_id)
        print(' Client Order Batch:', client_order_batch)
        if not client_order_batch: return json.dumps({'success': 'false', })

        in_process_id = COMMON.get_type_id(ClientOrderBatchStatus, 'InProcess')
        print(' Client Order Batch:', client_order_batch_id)

        if client_order_batch.client_order_batch_status_id != in_process_id:
            batch_status = COMMON.get_type_label(ClientOrderBatchStatus, client_order_batch.client_order_batch_status_id)
            return json.dumps({'success': 'false', 'message':'Order status is '+batch_status+' and cannot be shipped.',})

        #The Courier References are already populated by the time this is called.

        dbase_query = DBSession.query(ClientOrder).\
            filter(ClientOrder.client_order_batch_id == client_order_batch_id).\
            order_by(ClientOrder.order_number).\
            all()
        for order in dbase_query:
            CLIENT_ORDER.client_order_branch_ship(order.id)

        client_order_batch.client_order_batch_status_id = COMMON.get_type_id(ClientOrderBatchStatus, 'Complete')
        DBSession.flush()

        return json.dumps({'success': 'true', })

    def update_soh(self, *args, **kwargs):
        #We assume that this is a pack and not a sleeve or outer box.
        print('started update SOH')
        store_location_id = kwargs.get('store_location_id', None)
        delete_first = kwargs.get('delete_first', False)
        # start_reorder = kwargs.get('start_reorder', False)
        # batch_import_id = kwargs.get('batch_import_id', None)
        result = LOGGING.add_audit_log(**{
            'audit_action_id': COMMON.get_type_id(AuditAction, 'Audit'),
            'audit_type_id': COMMON.get_type_id(AuditType, 'RecalculateSOH'),
            'message': 'Started Update All SOH.',
        })
        print('started update log', result)

        if delete_first and not store_location_id:
            del_list = DBSession.query(ProductStoreLevel).all()
            #delete these records.
            for item in del_list:
                DBSession.delete(item)
            DBSession.flush()

        OPERATIONAL.rebuild_all_soh(store_location_id)

        # if start_reorder:
        #     #TGJ! This should be a asynchronous call
        #     print('#############################################################################')
        #     print('TGJ: Todo: This call needs to be a asynchronous call')
        #     print('#############################################################################')
        #
        #     self.check_branch_level(**{'batch_import_id': batch_import_id })
        #
        LOGGING.add_audit_log(**{
            'audit_action_id': COMMON.get_type_id(AuditAction, 'Audit'),
            'audit_type_id': COMMON.get_type_id(AuditType, 'RecalculateSOH'),
            'message': 'Completed Update All SOH.',
        })
        print('completed update SOH')
        return json.dumps({'success': 'true', })

    @expose()
    def move_pallet(self, *args, **kwargs):
        pallet_id = kwargs.get('pallet_id', None)
        in_store_location_id = kwargs.get('store_location_id', None)
        if not pallet_id \
           or not in_store_location_id:
            return json.dumps({'success': 'false', })

        store_location_id = int(in_store_location_id)
        pallet = Pallet.by_id(pallet_id)
        if not pallet: return json.dumps({'success': 'false', })

        old_store_location_id = pallet.store_location_id
        if old_store_location_id == store_location_id:
            return json.dumps({'success': 'false', })

        bulk_store_location_id = COMMON.get_bulk_store_location_id()
        cage_store_location_id = COMMON.get_cage_store_location_id()
        bulk_2_cage = False
        if old_store_location_id == bulk_store_location_id \
           and store_location_id == cage_store_location_id:
           bulk_2_cage = True

        pack_id = COMMON.get_type_id(PackingType, 'Pack')
        sleeve_id = COMMON.get_type_id(PackingType, 'Sleeve')
        inner_id = COMMON.get_type_id(PackingType, 'InnerBox')
        outer_id = COMMON.get_type_id(PackingType, 'OuterBox')

        print('Start Moving Pallet.')
        #get a complete list of packs
        pack_card = DBSession.query(PackingDetail, Card).\
            filter(PackingDetail.id == Card.packing_detail_id).\
            filter(PackingDetail.pallet_id == pallet_id).\
            first()
        if not pack_card: return json.dumps({'success': 'false', })
        product_id = pack_card[1].product_id
        product = Product.by_id(product_id)

        level_1_id = product.level_1_type_id
        level_2_id = product.level_2_type_id
        level_3_id = product.level_3_type_id
        reorder_id = product.client_reorder_type_id

        #get a complete list of packs
        level_1_list = DBSession.query(PackingDetail).\
            filter(PackingDetail.pallet_id == pallet_id).\
            filter(PackingDetail.packing_type_id == level_1_id).\
            order_by(PackingDetail.pallet_id, PackingDetail.reference_number).\
            all()

        if not level_1_list:
            print('Moving Pallet. Level1 Packs not found.')
            message = 'Pallet '+pallet.pallet_number+' was not moved.'
            LOGGING.add_audit_log(**{
                'audit_action_id': COMMON.get_type_id(AuditAction, 'Audit'),
                'audit_type_id': COMMON.get_type_id(AuditType, 'GoodsMovement'),
                'key': pallet_id,
                'key_auxillary': old_store_location_id ,
                'key_auxillary2': store_location_id ,
                'message': message,
            })
            return json.dumps({'success': 'false', })

        #move the pallet here.
        pallet.store_location_id = store_location_id
        DBSession.flush()

        remove_records = False
        remove_outer = True if (bulk_2_cage and reorder_id == level_1_id) else False

        print('Moving Pallet Level 1. Calling Move Pack List.', len(level_1_list), remove_records, remove_outer)
        self.move_pack_list(level_1_list, store_location_id, bulk_2_cage, remove_outer, remove_records)

        remove_records = True if (bulk_2_cage and reorder_id == level_1_id) else False
        remove_outer = True if (bulk_2_cage and reorder_id == level_2_id) else False
        #get a complete list of packs
        level_2_list = DBSession.query(PackingDetail).\
            filter(PackingDetail.pallet_id == pallet_id).\
            filter(PackingDetail.packing_type_id == level_2_id).\
            order_by(PackingDetail.pallet_id, PackingDetail.reference_number).\
            all()

        print('Moving Pallet Level 2. Calling Move Pack List.', len(level_1_list), remove_records, remove_outer)
        if level_2_list:
            self.move_pack_list(level_2_list, store_location_id, bulk_2_cage, remove_outer, remove_records)

        remove_records = True if (bulk_2_cage and reorder_id == level_2_id) else False
        remove_outer = True if (bulk_2_cage and reorder_id == level_3_id) else False
        #get a complete list of packs
        level_3_list = DBSession.query(PackingDetail).\
            filter(PackingDetail.pallet_id == pallet_id).\
            filter(PackingDetail.packing_type_id == level_3_id).\
            order_by(PackingDetail.pallet_id, PackingDetail.reference_number).\
            all()

        print('Moving Pallet Level 3. Calling Move Pack List.', len(level_1_list), remove_records, remove_outer)
        if level_3_list:
            self.move_pack_list(level_3_list, store_location_id, bulk_2_cage, remove_outer, remove_records)

        if bulk_2_cage:
            #Delete the Pallet
            DBSession.delete(pallet)
        DBSession.flush()

        #update the SOH
        print('Started SOH. Location Old.')
        OPERATIONAL.rebuild_all_soh(old_store_location_id)

        print('Started SOH. Location New.')
        OPERATIONAL.rebuild_all_soh(store_location_id)

        print('Completed SOH.')
        message = 'Pallet '+pallet.pallet_number+' was moved.'
        LOGGING.add_audit_log(**{
            'audit_action_id': COMMON.get_type_id(AuditAction, 'Audit'),
            'audit_type_id': COMMON.get_type_id(AuditType, 'GoodsMovement'),
            'key': pallet_id,
            'key_auxillary': old_store_location_id ,
            'key_auxillary2': store_location_id ,
            'message': message,
        })
        print('Completed Pallet Move.')
        return json.dumps({'success': 'true', })

    def move_pack_list(self, level_list=None, store_location_id=None, bulk_2_cage=False, remove_outer=False, remove_records=False, *args, **kwargs):
        print('     Started Move Pack List.',len(level_list), bulk_2_cage, remove_outer, remove_records)
        if not level_list or not store_location_id: return
        this_cnt = 0
        for item in level_list:
            this_cnt += 1
            if remove_records:
                DBSession.delete(item)
            else:
                item.store_location_id = store_location_id
                if bulk_2_cage: item.pallet_id = None
                if remove_outer: item.outer_pack_id = None
                DBSession.flush()

                card_list = DBSession.query(Card).\
                    filter(Card.packing_detail_id == item.id).\
                    order_by(Card.tracking_number).\
                    all()

                for card in card_list:
                    card.store_location_id = store_location_id
                    OPERATIONAL.write_card_history(card.id, card.card_status_id, card.store_location_id)
                DBSession.flush()
        DBSession.flush()
        print('     Completed Move Pack List. processed ', this_cnt)
        return

    @expose()
    def move_package(self, *args, **kwargs):
        packing_detail_id = kwargs.get('packing_detail_id', None)
        client_branch_id = kwargs.get('client_branch_id', None)
        destin_location_id = kwargs.get('store_location_id', None)
        destin_packing_detail_id = kwargs.get('destin_packing_detail_id', None)
        destin_pallet_id = kwargs.get('destin_pallet_id', None)
        user_id = kwargs.get('user_id', None)
        if not user_id:
            usernow = request.identity.get('user', {})
            user_id = usernow.id

        if not packing_detail_id or not user_id:
            return json.dumps({'success': 'false', })

        pack = PackingDetail.by_id(packing_detail_id)
        if not pack: return json.dumps({'success': 'false', })

        if client_branch_id:
            store = DBSession.query(Store).\
                filter(Store.client_branch_id==client_branch_id).\
                first()
            store_location = DBSession.query(StoreLocation).\
                filter(StoreLocation.store_id==store.id).\
                first()
            destin_location_id = store_location.id

        quarantine_store_location_id = COMMON.get_quarantine_store_location_id(COMMON.get_quarantine_store_id())
        is_from_quarantine = True if pack.store_location_id == quarantine_store_location_id else False
        is_to_quarantine = True if destin_location_id == quarantine_store_location_id else False
        print('IDs', destin_location_id, destin_packing_detail_id, destin_pallet_id)
        if destin_location_id:
            pack.store_location_id = destin_location_id
        if destin_packing_detail_id:
            pack.outer_pack_id = destin_packing_detail_id
        if destin_pallet_id:
            pack.pallet_id = destin_pallet_id
        DBSession.flush()

        if is_to_quarantine or is_from_quarantine:
            CARD.quarantine_card(is_to_quarantine, is_from_quarantine, pack.id)

        #first call
        self.move_child(pack.id, 1, destin_location_id, is_to_quarantine, is_from_quarantine)

        pack_name = COMMON.get_type_label(PackingType, pack.packing_type_id)
        message = pack_name+' '+pack.reference_number+' was moved '
        LOGGING.add_audit_log(**{
            'audit_action_id': COMMON.get_type_id(AuditAction, 'Audit'),
            'audit_type_id': COMMON.get_type_id(AuditType, 'GoodsMovement'),
            'key': destin_location_id,
            'key_auxillary': destin_packing_detail_id ,
            'key_auxillary2': destin_pallet_id ,
            'message': message,
        })
        return json.dumps({'success': 'true', })

    def move_stock(self, *args, **kwargs):
        packing_detail_id = kwargs.get('packing_detail_id', None)
        #product_id = kwargs.get('product_id', None)
        destin_location_id = kwargs.get('destin_location_id', None)
        destin_packing_detail_id = kwargs.get('destin_packing_detail_id', None)
        destin_pallet_id = kwargs.get('destin_pallet_id', None)
        user_id = kwargs.get('user_id', None)

        if not packing_detail_id \
           or not destin_packing_detail_id \
           or not user_id:
            return json.dumps({'success': 'false', })

        pack = PackingDetail.by_id(packing_detail_id)
        destin_pack = PackingDetail.by_id(destin_packing_detail_id)
        if not pack or not destin_pack:
            return json.dumps({'success': 'false', })

        quarantine_store_id = COMMON.get_quarantine_store_id()
        quarantine_store_location_id = COMMON.get_quarantine_store_location_id()
        is_from_quarantine = True if pack.store_location_id == quarantine_store_location_id else False
        is_to_quarantine = True if destin_location_id == quarantine_store_location_id else False

        if destin_location_id:
            pack.store_location_id = destin_location_id
        pack.outer_pack_id = destin_packing_detail_id
        pack.pallet_id = destin_pallet_id
        DBSession.flush()

        CARD.quarantine_card(is_to_quarantine, is_from_quarantine, pack.id)

        #first call
        self.move_child(pack.id, 1, is_to_quarantine, is_from_quarantine)

        pack_name = COMMON.get_type_label(PackingType, pack.packing_type_id)
        message = pack_name+' '+pack.reference_number+' was moved '
        LOGGING.add_audit_log(**{
            'audit_action_id': COMMON.get_type_id(AuditAction, 'Audit'),
            'audit_type_id': COMMON.get_type_id(AuditType, 'GoodsMovement'),
            'key': destin_location_id,
            'key_auxillary': destin_packing_detail_id ,
            'key_auxillary2': destin_pallet_id ,
            'message': message,
        })
        return json.dumps({'success': 'true', })

    def move_child(self, packing_detail_id=None, counter=1, destin_location_id = None, is_to_quarantine=False, is_from_quarantine=False, *args, **kwargs):
        if not packing_detail_id or counter > 5: return
        pack = PackingDetail.by_id(packing_detail_id)
        dbase_query = DBSession.query(PackingDetail).\
            filter(PackingDetail.outer_pack_id == packing_detail_id).\
            order_by(PackingDetail.reference_number).\
            all()

        if dbase_query:
            counter += 1
            for child in dbase_query:
                child.store_location_id = pack.store_location_id
                child.pallet_id = pack.pallet_id
                DBSession.flush()

                if is_to_quarantine or is_from_quarantine:
                    CARD.quarantine_card(is_to_quarantine, is_from_quarantine, child.id)

                #first call
                self.move_child(child.id, counter, destin_location_id, is_to_quarantine, is_from_quarantine)

        else: 
            in_stock_id = COMMON.get_type_id(CardStatus, 'InStock')
            branch_store_id = COMMON.get_type_id(CardStatus, 'BranchStore')

            dbase_query = DBSession.query(Card). \
                filter(Card.packing_detail_id == packing_detail_id).\
                filter(or_(
                    Card.card_status_id==in_stock_id,
                    Card.card_status_id==branch_store_id,)). \
                all()
            if dbase_query:
                for card in dbase_query:
                    OPERATIONAL.move_card(**{
                        'card': card ,
                        'store_location_id': destin_location_id ,
                        'card_status_id': in_stock_id ,
                        'packing_detail_id': card.packing_detail_id ,
                    })
        return

    def cancel_client_order_batch(self, client_order_batch_id=None, *args, **kwargs):
        if not client_order_batch_id: return {'success': 'false', }

        client_order_batch = ClientOrderBatch.by_id(client_order_batch_id)
        if not client_order_batch: return {'success': 'false', }

        order_cancelled_id = COMMON.get_type_id(ClientOrderStatus, 'Cancelled')
        batch_cancelled_id = COMMON.get_type_id(ClientOrderBatchStatus, 'Cancelled')

        client_order_list = DBSession.query(ClientOrder).\
            filter(ClientOrder.client_order_batch_id==client_order_batch_id).\
            all()
        if not client_order_list: return {'success': 'false', }

        for client_order in client_order_list:
            client_order.client_order_status_id = order_cancelled_id
            DBSession.flush()
            OPERATIONAL.write_client_order_history(client_order.id, order_cancelled_id)

            order_details = DBSession.query(ClientOrderDetail).\
                filter(ClientOrderDetail.client_order_id==client_order.id).\
                all()
            if not order_details: continue
            for order_detail in order_details:
                result = CLIENT_ORDER.pick_product_fifo_reverse(order_detail.id, order_detail.product_id, order_detail.filled_quantity)
                success = result.get('success')
                message = result.get('message')
                status = result.get('status')
                # if success == 'true':
                #     #change the status and clobber

        client_order_batch.client_order_batch_status_id = batch_cancelled_id
        OPERATIONAL.write_client_order_batch_history(client_order_batch.id, client_order_batch.client_order_batch_status_id)
        DBSession.flush()

        #Update Outbound and Cage SOH
        outbound_store_location_id = outbound_store_location_id = COMMON.get_outbound_store_location_id()

        OPERATIONAL.rebuild_all_soh(outbound_store_location_id)
        OPERATIONAL.rebuild_all_soh(COMMON.get_cage_store_location_id())
        return {'success': 'true', }

    def move_card_for_pack(self, pack_id=None, store_location_id=None, *args, **kwargs):
        if not pack_id: return
        card_list = DBSession.query(Card).\
            filter(Card.packing_detail_id == pack_id).\
            all()

        if card_list:
            for card in card_list:
                OPERATIONAL.move_card(**{
                    'card': card ,
                    'store_location_id': store_location_id ,
                    'card_status_id': COMMON.get_type_id(CardStatus, 'InStock') ,
                    'packing_detail_id': card.packing_detail_id ,
                })
        return

    def get_product_stock_level(self, *args, **kwargs):
        product_id = kwargs.get('product_id', None)
        if not product_id: return json.dumps({'success': 'false'})

        product = Product.by_id(product_id)

        bulk_store_id = COMMON.get_bulk_store_id()
        cage_store_id = COMMON.get_cage_store_id()

        available_bulk = CLIENT_ORDER.get_available_card(product_id, bulk_store_id)
        available_cage = CLIENT_ORDER.get_available_card(product_id, cage_store_id)
        total_available = (available_bulk+available_cage)
        reorder_required = True if (product.reorder_quantity > 0) and (total_available <= product.reorder_quantity) else False
        above_reorder_level = (total_available - product.reorder_quantity)

        return json.dumps({
            'success': 'true',
            'available_bulk' : available_bulk ,
            'available_cage' : available_cage ,
            'total_available' : total_available ,
            'reorder_required' : reorder_required ,
            'above_reorder_level' : above_reorder_level ,
            })
