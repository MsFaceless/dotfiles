from migration_utils import DataFrameBuilder, CleanDataFrame
from type_utils import person_types


class PersonDataFrameBuilder:

    def __init__(self):
        #self.person_file_name = "erm_person_20200524_093704.txt"
        #self.person_identity_file_name = "erm_person_identity_20200524_093723.txt"
        #self.person_contact_file_name = "erm_contact_20200524_093737.txt"

        self.person_file_name = "erm_person_20201123_074124.txt"
        self.person_identity_file_name = "erm_person_identity_20201123_074144.txt"
        self.person_contact_file_name = "erm_contact_20201123_074200.txt"
        self.person_data_frame = None
        self.person_identity_data_frame = None
        self.person_contact_data_frame = None
        self.fail_message = None

    def get_person_data_frame(self):
        data_frame = DataFrameBuilder(). \
            set_file_name(self.person_file_name). \
            set_relevant_columns([
                'ClientNo',
                'person_title',
                'first_name',
                'last_name',
                'date_of_birth',
                'gender',
                'language_obj',
            ]). \
            set_new_column_names({
                'person_title': 'entity_person_title_id',
                'first_name': 'name',
                'last_name': 'surname',
                'gender': 'person_gender_type_id',
                'language_obj': 'language_id',
            }). \
            create_dataframe(). \
            rename_columns(). \
            return_dataframe()
        if data_frame:
            if data_frame['success']:
                self.person_data_frame = data_frame['data']
            else:
                self.fail_message = data_frame
        else:
            self.fail_message = {"success": False, "data": "No Person DataFrame from DataFrameBuilder"}
        return self

    def get_person_identity_data_frame(self):
        if self.fail_message:
            return self
        data_frame = DataFrameBuilder(). \
            set_file_name(self.person_identity_file_name). \
            set_relevant_columns([
                'ClientNo',
                'identity_type_obj',
                'identity_number',
                'primary_identification'
            ]). \
            set_new_column_names({
                'identity_type_obj': 'identity_type_id',
                'identity_number': 'number',
            }). \
            create_dataframe(). \
            rename_columns(). \
            return_dataframe()
        if data_frame:
            if data_frame['success']:
                self.person_identity_data_frame = data_frame['data']
            else:
                self.fail_message = data_frame
        else:
            self.fail_message = {"success": False, "data": "No PersonIdentity DataFrame from DataFrameBuilder"}
        return self

    def get_person_contact_data_frame(self):
        if self.fail_message:
            return self
        data_frame = DataFrameBuilder(). \
            set_file_name(self.person_contact_file_name). \
            set_relevant_columns([
                'ClientNo',
                'contact_line1',
                'contact_text'
            ]). \
            set_new_column_names({
                'contact_line1': 'mobile'
            }). \
            create_dataframe(). \
            rename_columns(). \
            return_dataframe()
        if data_frame:
            if data_frame['success']:
                self.person_contact_data_frame = data_frame['data']
            else:
                self.fail_message = data_frame
        else:
            self.fail_message = {"success": False, "data": "No PersonContact DataFrame from DataFrameBuilder"}
        return self

    def remove_non_cellphone_contact_from_person_contact_df(self):
        if self.fail_message:
            return self
        self.person_contact_data_frame = CleanDataFrame().keep_rows_equal_to_certain_value(
            self.person_contact_data_frame, 'contact_text', "Cellphone")
        return self

    def remove_non_primary_identification_from_person_identity_df(self):
        if self.fail_message:
            return self
        self.person_identity_data_frame = CleanDataFrame().remove_rows_with_certain_value(
            self.person_identity_data_frame, 'primary_identification', 'No')
        return self

    def join_person_df_and_person_identity_df(self):
        if self.fail_message:
            return self
        self.person_data_frame = self.person_data_frame.join(self.person_identity_data_frame.set_index('ClientNo'),
                                                             on='ClientNo')
        self.person_identity_data_frame = None
        return self

    def join_person_df_and_person_contact_df(self):
        if self.fail_message:
            return self
        self.person_data_frame = self.person_data_frame.join(self.person_contact_data_frame.set_index('ClientNo'),
                                                             on='ClientNo')
        self.person_contact_data_frame = None
        return self

    def set_correct_date_format(self):
        if self.fail_message:
            return self
        self.person_data_frame = CleanDataFrame().convert_date_columns_to_correct_format(self.person_data_frame, 'date_of_birth')
        return self

    def replace_nan_with_empty_string(self):  # TODO if this doesn't work then use dropna
        if self.fail_message:
            return self
        self.person_data_frame.fillna(value='', inplace=True)
        return self

    def replace_type_ids_with_temp_values(self):  # TODO this is a temp solution until type tables are available
        if self.fail_message:
            return self.fail_message
        self.person_data_frame['entity_person_title_id'] = 21 # unknown
        self.person_data_frame['person_gender_type_id'] = 4 # unknown
        self.person_data_frame['language_id'] = 123 # english
        self.person_data_frame['identity_type_id'] = 3 # unknown
        return self

    def _get_rocket_type_gender_value(self, type_value: str):
        type_dict = person_types['person_gender_type'].get(type_value, None)
        if type_dict:
            rocket_type = type_dict["rocket_id"]
        else:
            rocket_type = 4
        return rocket_type

    def replace_type_ids_with_rocket_values(self):
        if self.fail_message:
            return self.fail_message
        self.person_data_frame['person_gender_type_id'] = self.person_data_frame['person_gender_type_id'].apply(self._get_rocket_type_gender_value)
        return self

    def build_person_data_frame(self):
        if self.fail_message:
            return self.fail_message
        else:
            return {'success': True, 'data': self.person_data_frame}


class AddressDataFrameBuilder:

    def __init__(self):
        #self.address_file_name = 'agm_address_20200524_093732.txt'
        self.address_file_name = 'agm_address_20201123_074153.txt'
        self.address_data_frame = None
        self.fail_message = None

    def get_address_data_frame(self):
        data_frame = DataFrameBuilder(). \
            set_file_name(self.address_file_name). \
            set_relevant_columns([
                'ClientNo',
                'address_type_obj',
                'post_code',
                'address_line1',
                'address_line2',
                'address_line3',
                'address_line4'
            ]). \
            set_new_column_names({
                'address_type_obj': 'address_type_id',
                'post_code': 'postal_code'
            }). \
            create_dataframe(). \
            rename_columns(). \
            return_dataframe()
        if data_frame:
            if data_frame['success']:
                self.address_data_frame = data_frame['data']
            else:
                self.fail_message = data_frame
        else:
            self.fail_message = {"success": False, "data": "No PersonAddress DataFrame from DataFrameBuilder"}
        return self

    def combine_address_lines(self):
        if self.fail_message:
            return self
        self.address_data_frame['address_line'] = self.address_data_frame[
            ['address_line1', 'address_line2', 'address_line3', 'address_line4']].apply(lambda x: x.str.cat(sep=', '),
                                                                                        axis=1)
        return self

    def drop_old_address_lines(self):
        if self.fail_message:
            return self
        self.address_data_frame.drop(columns=[
            'address_line1',
            'address_line2',
            'address_line3',
            'address_line4'],
            inplace=True)
        return self

    def replace_address_type_obj_with_type_id(self):  # TODO this is a temp solution until type tables are available
        if self.fail_message:
            return self
        self.address_data_frame['address_type_id'] = self.address_data_frame['address_type_id'].apply(
            lambda x: 2 if x == 'PHY' else 1)
        return self

    def replace_nan_with_empty_string(self):  # TODO if this doesn't work then use dropna
        if self.fail_message:
            return self
        self.address_data_frame.fillna(value='', inplace=True)
        return self

    def build_address_data_frame(self):
        if self.fail_message:
            return self.fail_message
        else:
            return {'success': True, 'data': self.address_data_frame}


class BankDataFrameBuilder:

    def __init__(self):
        #self.bank_file_name = 'fim_bank_account_detail_20200524_093804.txt'
        self.bank_file_name = 'fim_bank_account_detail_20201123_074231.txt'
        self.bank_data_frame = None
        self.fail_message = None

    def get_bank_data_frame(self):
        data_frame = DataFrameBuilder(). \
            set_file_name(self.bank_file_name). \
            set_relevant_columns([
                'ClientNo',
                'currency_obj',
                'creditcard_swift_code',
                'account_name',
                'bank_branch_obj',
                'account_number'
            ]). \
            set_new_column_names({
                'currency_obj': 'currency_id',
                'creditcard_swift_code': 'swift_code',
                'account_name': 'account_holder',
                'bank_branch_obj': 'branch_code'
            }). \
            create_dataframe(). \
            rename_columns(). \
            return_dataframe()
        if data_frame:
            if data_frame['success']:
                self.bank_data_frame = data_frame['data']
            else:
                self.fail_message = data_frame
        else:
            self.fail_message = {"success": False, "data": "No PersonBank DataFrame from DataFrameBuilder"}
        return self

    def replace_type_ids_with_temp_values(self):  # TODO this is a temp solution until type tables are available
        if self.fail_message:
            return self.fail_message
        self.bank_data_frame['bank_id'] = 1
        self.bank_data_frame['currency_id'] = 1
        self.bank_data_frame['iban'] = 1234567890
        return self

    def replace_nan_with_empty_string(self):  # TODO if this doesn't work then use dropna
        if self.fail_message:
            return self
        self.bank_data_frame.fillna(value='', inplace=True)
        return self

    def build_bank_data_frame(self):
        if self.fail_message:
            return self.fail_message
        else:
            return {'success': True, 'data': self.bank_data_frame}
