import requests
from datetime import datetime, date, time, timedelta
import csv
import time as ogtime
import os
import pickle
import json
import numpy as np
import cv2
import shutil
import base64
import random
import subprocess
import string
import threading

from operator import itemgetter
from dotenv import dotenv_values

from PIL import Image
from lib import betterparse as bp
#from lib import superres as sr
from lib.detector import detect_persons
#from lib.superres import supersize_espcn
from lib import generate_detections as gdet
from lib.safet import send_unique_passengers

from yolo import YOLO as YOLOV4


from deep_sort import preprocessing
from deep_sort import nn_matching
from deep_sort.detection import Detection
from deep_sort.tracker import Tracker

def pathify(path_from_curdir):
    curdir = os.path.abspath(os.path.curdir)
    expanded_path = os.path.abspath(os.path.join(curdir, path_from_curdir))
    return expanded_path

def get_random_string(length):
    letters = string.ascii_lowercase
    result_str = ''.join(random.choice(letters) for i in range(length))
    return result_str

global YOLO
YOLO = YOLOV4()

global show_output
show_output = False

global active_trackers
active_trackers = {}

global active_channels
active_devices = ['01348']
active_channels = ['3', '4']
active_tracker_dict = {}
devices_dict = {'01348':0, '00274':0, '01855':0}

env_dict = dotenv_values()
tripkeeper_url = env_dict.get("TRIPKEEPER_URL")

curdir = os.path.abspath(os.path.curdir)
input_dir = os.path.join(curdir, 'input_dir')

this_input_dir = os.path.abspath(".")
input_models_dir = os.path.join(this_input_dir, "models")
input_cfg_dir = os.path.join(this_input_dir, "config")
input_weights_dir = os.path.join(this_input_dir, "weights")
input_classes_dir = os.path.join(this_input_dir, "classes")

def parse_data():
    daysdict = bp.parse_directory_filenames_to_daysdict(target_dir=input_dir)
    day_device_dict = bp.parse_daysdict_to_day_device_dict(daysdict=daysdict)
    return day_device_dict
    day_device_sequence_dict = {day:{device_id :{} for device_id in device_dict.keys()} for day, device_dict in day_device_dict.items()}

    for day, device_dict in day_device_dict.items():

        for device_id, record_list in device_dict.items():
            sequence_dict = bp.parse_day_device_dict_to_day_device_sequence_dict(day=day, device_id=device_id, record_list=record_list)
            day_device_sequence_dict[day][device_id]= sequence_dict
    return day_device_sequence_dict

def get_base64_encoded_image(image):
    _, im_arr = cv2.imencode('.jpg', image)
    im_bytes = im_arr.tobytes()
    im_b64 = base64.b64encode(im_bytes)
    return im_b64

def get_current_segment(current_segment=None, frame_datetime=None):
    if not frame_datetime: return False

def get_device_tracker_dict(device_number=None):
    if not device_number: return False
    device_tracker_dict = active_tracker_dict.get(device_number, None)
    if not device_tracker_dict: active_tracker_dict[device_number] = {}
    device_tracker_dict = active_tracker_dict.get(device_number, None)
    return device_tracker_dict

def init_channel_tracker_dict():
    channel_tracker_dict = {}
    max_cosine_distance = 0.3
    nn_budget = None
    nms_max_overlap = 1.0

    model_filename = os.path.join(input_models_dir, 'mars-small128.pb')
    encoder = gdet.create_box_encoder(model_filename, batch_size=1)

    metric = nn_matching.NearestNeighborDistanceMetric("cosine", max_cosine_distance, nn_budget)
    tracker = Tracker(metric)
    channel_tracker_dict = {
            'tracker':tracker,
            'encoder':encoder,
            'metric':metric,
            'nn_budget':nn_budget,
            'max_cosine_distance':max_cosine_distance,
            'nms_max_overlap':nms_max_overlap,

            'frames_list':[],
            }
    return channel_tracker_dict

def get_channel_tracker_dict(device_number=None, channel=None):
    if not device_number or not channel: return False
    device_dict = get_device_dict(device_number)
    channel_tracker_dict = device_dict.get(str(channel))
    #print(channel_tracker_dict)
    return channel_tracker_dict

def update_tracker(**frame_args):
    device_number = frame_args.get('device_number', None)
    channel = frame_args.get('channel', None)
    sres_frame = frame_args.get('sres_frame')
    if not device_number or not channel: return False
    frame_persisted = persist_frame(frame_args)

    channel = str(channel)
    channel_tracker_dict = get_channel_tracker_dict(device_number, channel)
    #print(channel_tracker_dict.keys())
    tracker = channel_tracker_dict.get('tracker')
    frames_list = channel_tracker_dict.get('frames_list')
    frames_list.append(frame_args)

    encoder = channel_tracker_dict.get('encoder')
    max_cosine_distance = channel_tracker_dict.get('max_cosine_distance')
    nn_budget = channel_tracker_dict.get('nn_budget')
    nms_max_overlap = channel_tracker_dict.get('nms_max_overlap')
    multipass_count = 3

    image = Image.fromarray(sres_frame[..., ::-1])  # bgr to rgb
    boxes, confidence, classes = YOLO.detect_image(image)
    #print("Printing Boxes")
    #print(boxes)
    #print("Printing Confidence")
    #print(confidence)
    features = encoder(sres_frame, boxes)

    detections = [Detection(bbox, confidence, cls, feature) for bbox, confidence, cls, feature in
                  zip(boxes, confidence, classes, features)]

    boxes = np.array([d.tlwh for d in detections])
    scores = np.array([d.confidence for d in detections])

    classes = np.array([d.cls for d in detections])
    indices = preprocessing.non_max_suppression(boxes, nms_max_overlap, scores)
    detections = [detections[i] for i in indices]

    for frame in range(multipass_count):

        tracker.predict()
        tracker.update(detections)

    #print('update_tracker DONE - return True')
    return True

def get_device_dict(device_number=None):
    device_dict = active_trackers.get(device_number, None)
    if device_dict == None: device_dict = {channel:{} for channel in active_channels}
    active_trackers[device_number] = device_dict
    return device_dict

def get_sres_frame(filepath=None):
    if not filepath: return False
    if not os.path.exists(filepath): return False
    try: frame = cv2.imread(filepath)
    except: return False
    sres_frame = supersize_espcn(frame)
    return sres_frame

def reset_trackers(device_number=None):
    if not device_number: return False
    unique_persons = 0

    frames_list = []
    for channel in active_channels:
        completed_tracker_dict = get_tracker(device_number, channel)
        completed_tracker = completed_tracker_dict.get('tracker')
        channel_detections_list = []
        frames_list.extend(completed_tracker_dict.get('frames_list'))
        for track in completed_tracker.tracks:
            if not track.is_confirmed() or track.time_since_update > 1: continue
            #bbox = track.to_tlbr()

            adc = "%.2f" % (track.adc * 100) + "%"
            track_id = str(track.track_id)

            if not track_id in channel_detections_list: channel_detections_list.append(track_id)
        unique_persons += len(channel_detections_list)
        #del completed_tracker
    device_dict = get_device_dict(device_number)
    sorted_frames_list = sorted(frames_list, key=itemgetter("datetime"), reverse=True)
    print()
    print(len(sorted_frames_list))
    print()
    persons_broadcasted = broadcast_unique_persons(device_number, sorted_frames_list, unique_persons)
    #print("Printing Unique Persons")
    #print(unique_persons)
    del active_trackers[device_number]
    return True

def get_tracker(device_number=None, channel=None):
    if not device_number or not channel: return False

    device_dict = get_device_dict(device_number)
    channel_tracker_dict = device_dict.get(channel)
    return channel_tracker_dict

def init_trackers(device_number=None):
    print("initing Trackers")
    if not device_number: return False

    if active_trackers.get(device_number, None):
        #del active_trackers[device_number]
        pass

    device_dict = get_device_dict(device_number)
    channels = device_dict.keys()
    for channel in channels:
        channel = str(channel)
        channel_tracker_dict = init_channel_tracker_dict()
        device_dict[channel] = channel_tracker_dict
    active_trackers[device_number] = device_dict
    return True

def broadcast_unique_persons(device_number=None, frames_list=None, unique_persons=None):
    if not device_number or not frames_list or not unique_persons: return False
    print("Unique Personses")
    print(unique_persons)

    start_frame = frames_list.pop()
    start_timestamp = start_frame.get('datetime')
    start_datetime_string = start_timestamp.strftime("%Y%m%d_%H%M%S")

    if len(frames_list) == 0:
        end_timestamp = start_frame.get('datetime')
        end_datetime_string = start_timestamp.strftime("%Y%m%d_%H%M%S")
    else:
        end_frame = frames_list[-1]
        end_timestamp = end_frame.get('datetime')
        end_datetime_string = end_timestamp.strftime("%Y%m%d_%H%M%S")

    post_occupancy_url = f"{tripkeeper_url}/receive_occupancy?"
    occupancy_data = {}
    occupancy_data['passengers'] = int(unique_persons)
    occupancy_data['device_number'] = device_number
    occupancy_data['start_datetime_string'] = start_datetime_string
    occupancy_data['end_datetime_string'] = end_datetime_string

    occupancy_request = requests.post(post_occupancy_url, json=occupancy_data)
    if occupancy_request.status_code != 200: return False
    unique_passengers_broadcast = send_unique_passengers(device_number, start_timestamp, end_timestamp, unique_persons)
    print(unique_passengers_broadcast)
    if not unique_passengers_broadcast: return False
    print(occupancy_request.json())
    #del frames_list
    #del occupancy_data
    return True

def get_frames_list(device_number=None):
    if not device_number: return False

def broadcast_device_frames(device_number=None, frames_list=None):
    if not device_number or not frames_list: return False

    first = True
    previous_detections = 0
    current_detections = 0
    #yolov3_detections = 0

    previous_detections_dict = {}
    detections_dict = {}

    while True:
        previous_detections = sum([value for _, value in previous_detections_dict.items()])

        if first: 
            init_trackers(device_number)
            first = False

        if len(frames_list) == 0:
            ogtime.sleep(60)
            frames_list = get_frames_list(device_number)

        frame_record = frames_list.pop()

        channel = frame_record.get('channel', None)
        channel = str(channel)

        if channel not in active_channels: continue
        filename = frame_record.get('filename', None)
        print("*"*20)
        print("Processing: ", filename)
        print("Items remaining: ", len(frames_list))
        filepath = os.path.join(input_dir, filename)
        #sres_frame = get_sres_frame(filepath)
        sres_frame = cv2.imread(filepath)
        if not hasattr(sres_frame, 'any'): 
            print("This might be a broken file: opportunity to refetch specific files from Rory's")
            continue

        frame_record['sres_frame'] = sres_frame

        yolov3_detector = detect_persons(sres_frame)
        current_yolov3_detections = len(yolov3_detector.person_list)

        current_detections = detections_dict.get(channel, "A")
        if current_detections == 'A': detections_dict[channel] = current_yolov3_detections
        else: current_detections = current_yolov3_detections

        current_detections = sum([value for _, value in detections_dict.items()])

        print("Yolov3 Detections", current_yolov3_detections)
        del yolov3_detector
        frame_record['detections'] = current_yolov3_detections

        if previous_detections > 0 and current_detections == 0: reset_trackers(device_number)
        elif previous_detections == 0 and current_detections > 0: init_trackers(device_number)
        elif current_detections > 0: update_tracker(**frame_record)

        print("Current Yolov3 Detections both Channels: ", current_detections)

        archive_frame(device_number, frame_record)

        previous_detections_dict[channel] = current_yolov3_detections

        del sres_frame
        del frame_record['sres_frame']
    return True

def persist_frame(frame_record=None):
    if not frame_record: return False
    sres_frame = frame_record.get('sres_frame')
    b64_frame = get_base64_encoded_image(sres_frame)
    device_number = frame_record.get('device_number')
    channel = frame_record.get('channel')
    detections = frame_record.get('detections')
    datetime_string = frame_record.get('datetime_string')

    record_data = {
            'datetime_string':datetime_string,
            'channel':int(channel),
            'device_number':device_number,
            'detections':str(detections),
            'frame':b64_frame,
            }

    post_frame_url = f"{tripkeeper_url}/receive_frame?"
    record_data['frame'] = str(b64_frame, encoding='utf8')
    frame_request = requests.post(post_frame_url, json=record_data)
    if frame_request.status_code != 200: return False
    filename = frame_record.get('filename')
    filepath = os.path.join(input_dir, filename)
    os.remove(filepath)
    #del sres_frame
    #del b64_frame
    return True

def archive_frame(device_number=None, frame_record=None):
    if not device_number or not frame_record: return False
    filename = frame_record.get('filename')
    filepath = os.path.join(input_dir, filename)
    if not os.path.exists(filepath): return False
    archive_path = os.path.join(curdir, "archive")
    if not os.path.exists(archive_path): os.mkdir(archive_path)
    device_archive_path = os.path.join(archive_path, device_number)
    if not os.path.exists(device_archive_path): os.mkdir(device_archive_path)
    new_filepath = os.path.join(device_archive_path, filename)
    with open(filepath, "rb") as f:
        with open(new_filepath, "wb") as n: n.write(f.read())
    os.remove(filepath)
    return True

def spawn_emitters(device_channel_records_dict={}):
    active_trackers = {}

    if not device_channel_records_dict: return False

    for device_number, frames_list in device_frames_dict.items():
        print("Running Thread")
        if device_number not in active_devices:
            for frame_record in frames_list:
                archive_frame(device_number, frame_record)
            continue
        broadcast_device_frames(device_number, frames_list)
        print("Deadening Thread")

if __name__ == "__main__":
    #day_device_sequence_dict = parse_data()
    print("Spawn day_device_sequence_dict")
    #emit_data(day_device_sequence_dict)
    #dump_day_device_sequence_dict(day_device_sequence_dict)
    #device_channel_records_dict = bp.parse_directory_to_device_channel_dict(input_dir)
    device_frames_dict = bp.parse_directory_to_device_frames_dict(input_dir)
    emitters = spawn_emitters(device_frames_dict)

