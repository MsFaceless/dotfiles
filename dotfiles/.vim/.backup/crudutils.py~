from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
from sqlalchemy import func, desc, asc, or_
from decimal import Decimal
from datetime import datetime, date, time
from pydantic import BaseModel
from typing import Optional
from lib.validatorutils import SearchValidator
from dotenv import dotenv_values

env_dict = dotenv_values()
LIMIT = env_dict.get("LIMIT")

active_cruds = {}
sort_order_dict = {'descending':desc, 'ascending':asc}

def create_all_int_attribute_funcs(model_name, Model, column_name, python_type):
    int_func_dict = {}
    def get_get_is_greater_all():
        def get_is_greater_all(db:Session, attribute_value: python_type, search_validator: SearchValidator = SearchValidator()):
            limit = search_validator.limit
            sort_on = search_validator.sort_on
            sort_direction = sort_order_dict.get(search_validator.sort_direction)
            active_filter = getattr(Model, column_name)
            db_record = db.query(Model). \
                    filter(Model.bln_active==True). \
                    filter(active_filter>=attribute_value). \
                    order_by(sort_direction(sort_on)). \
                    limit(limit). \
                    all()
            if db_record and isinstance(db_record, list): returnable = [item for item in db_record]
            db.close()
            return returnable

        setattr(get_is_greater_all, "__name__", f"get_all_{model_name.lower()}_greater_{column_name.lower()}")
        setattr(get_is_greater_all, "__qualname__", f"get_all_{model_name.lower()}_greater_{column_name.lower()}")
        return get_is_greater_all
    
    int_func_dict[f'get_all_{column_name.lower()}_greater'] = get_get_is_greater_all()

    def get_get_is_less_all():
        def get_is_less_all(db:Session, attribute_value: python_type, search_validator: SearchValidator = SearchValidator()):
            limit = search_validator.limit
            sort_on = search_validator.sort_on
            sort_direction = sort_order_dict.get(search_validator.sort_direction)
            active_filter = getattr(Model, column_name)
            db_record = db.query(Model). \
                    filter(Model.bln_active==True). \
                    filter(active_filter<=attribute_value). \
                    order_by(sort_direction(sort_on)). \
                    limit(limit). \
                    all()
            if db_record and isinstance(db_record, list): returnable = [item for item in db_record]
            db.close()
            return returnable

        setattr(get_is_less_all, "__name__", f"get_all_{model_name.lower()}_less_{column_name.lower()}")
        setattr(get_is_less_all, "__qualname__", f"get_all_{model_name.lower()}_less_{column_name.lower()}")
        return get_is_less_all
    int_func_dict[f'get_all_{column_name.lower()}_less'] = get_get_is_less_all()

    def get_get_is_between_all():
        def get_is_between_all(db:Session, low_value: python_type, high_value: python_type, limit: int = LIMIT):
            sort_on = sort_order.sort_on
            sort_direction = sort_order_dict.get(sort_order.sort_direction)
            active_filter = getattr(Model, column_name)
            db_record = db.query(Model). \
                    filter(Model.bln_active==True). \
                    filter(low_value<=active_filter<=high_value). \
                    limit(limit). \
                    all()
            if db_record and isinstance(db_record, list): returnable = [item for item in db_record]
            db.close()
            return returnable

        setattr(get_is_between_all, "__name__", f"get_all_{model_name.lower()}_between_{column_name.lower()}")
        setattr(get_is_between_all, "__qualname__", f"get_all_{model_name.lower()}_between_{column_name.lower()}")
        return get_is_between_all

    int_func_dict[f'get_all_{column_name.lower()}_between'] = get_get_is_between_all()

    def get_get_is_outside_all():
        def get_is_outside_all(db:Session, low_value: python_type, high_value: python_type, limit: int = LIMIT):
            sort_on = sort_order.sort_on
            sort_direction = sort_order_dict.get(sort_order.sort_direction)
            active_filter = getattr(Model, column_name)
            db_record = db.query(Model). \
                    filter(Model.bln_active==True). \
                    filter(low_value>=active_filter>=high_value). \
                    limit(limit). \
                    all()
            if db_record and isinstance(db_record, list): returnable = [item for item in db_record]
            db.close()
            return returnable
        setattr(get_is_outside_all, "__name__", f"get_all_{model_name.lower()}_outside_{column_name.lower()}")
        setattr(get_is_outside_all, "__qualname__", f"get_all_{model_name.lower()}_outside_{column_name.lower()}")
        return get_is_outside_all

    int_func_dict[f'get_all_{column_name.lower()}_outside'] = get_get_is_outside_all()
    return int_func_dict

def get_required_args(Model, kwargs, update=False):
    model_columns = Model.__table__.columns
    ignore_columns = ['id', 'bln_edited', 'edited', 'edited_by', 'bln_active']
    if update: ignore_columns = ['added', 'edited', 'bln_edited']
    required_args = {}
    optional_args = {}
    for column in model_columns:
        optional_value = kwargs.get(column.name, None)
        if column.nullable or column.default:
            if optional_value: optional_args[column.name] = optional_value
            continue
        elif column.name in ignore_columns: continue
        required_value = kwargs.get(column.name, "SomeString")
        if required_value == "SomeString": continue
        required_args[column.name] = required_value
    for key, value in required_args.items():
        if value == None: return False
        elif value == 'string': return False
    return {'required': required_args, 'optional': optional_args}

def create_create_function(model_name=None, Model=None):
    my_columns = Model.__table__.columns

    def create(db: Session, **kwargs):
        if not db: return False
        print(kwargs)
        returnable = False
        args = get_required_args(Model, kwargs)
        print(args)
        if not args:  return False
        optional = args['optional']
        required = args['required']
        model_data = {}
        model_data.update(required)
        model_data.update(optional)

        try:
            returnable = {}
            db_record = Model(**model_data)
            db.add(db_record)
            db.commit()
            db.refresh(db_record)
            returnable = get_returnable_dict(db_record)
        except Exception as e:
            db.rollback()
        finally:
            db.close()
        return returnable

    model_name = model_name[:-4]
    function_name = f"create_{model_name.lower()}"
    setattr(create, "__name__", function_name)
    setattr(create, "__qualname__", function_name)
    return create

def create_update_function(model_name=None, Model=None):
    my_columns = Model.__table__.columns

    def update(db: Session, **kwargs):
        args = get_required_args(Model, kwargs, update=True)
        if not args:  return False
        optional = args['optional']
        required = args['required']
        model_data = {}
        model_data.update(required)
        model_data.update(optional)
        target_id = kwargs.get("id", None)
        if not target_id: return False
        try: exists = db.query(Model). \
                    filter(Model.id==target_id). \
                    one()
        except: exists = False
        if not exists: return False
        db_record = exists

        for k, v in model_data.items(): setattr(db_record, k, v)
        db_record.bln_edited = True
        #Do audit thangs
        returnable = False
        try: 
            db.add(db_record)
            db.commit()
            db.refresh(db_record)
            if db_record: returnable = get_returnable_dict(db_record)
        except Exception as e:
            db.rollback()
        finally:
            db.close()
        return returnable

    model_name = model_name[:-4]
    function_name = f"update_{model_name.lower()}"
    setattr(update, "__name__", function_name)
    setattr(update, "__qualname__", function_name)
    return update

def create_deactivate_function(model_name=None, Model=None):
    my_columns = Model.__table__.columns

    def deactivate(db: Session, target_id: int, added_by: int):
        returnable = False
        if not target_id: return False
        try: exists = db.query(Model). \
                    filter(Model.id==target_id). \
                    filter(Model.bln_active==True). \
                    one()
        except: exists = False
        if not exists: return False
        db_record = exists
        db_record.bln_active = False
        db_record.bln_edited = True
        db.add(db_record)
        if db_record: returnable = db_record.__dict__
        try: db.commit()
        except: db.rollback()
        finally:
            db.flush()
            db.close()
        return returnable

    function_name = f"deactivate_{model_name.lower()}"
    setattr(deactivate, "__name__", function_name)
    setattr(deactivate, "__qualname__", function_name)
    return deactivate


def create_delete_function(model_name=None, Model=None):
    my_columns = Model.__table__.columns

    def delete(db: Session, target_id: int, added_by: int):
        returnable = False
        if not target_id: return False
        try: exists = db.query(Model). \
                    filter(Model.id==target_id). \
                    filter(Model.bln_active==True). \
                    one()
        except: exists = False
        if not exists: return False
        db_record = exists
        db_record.bln_active = False
        db_record.bln_edited = True
        db.delete(db_record)
        if db_record: returnable = db_record.__dict__
        try: db.commit()
        except: db.rollback()
        finally:
            db.flush()
            db.close()
        return returnable

    function_name = f"delete_{model_name.lower()}"
    setattr(delete, "__name__", function_name)
    setattr(delete, "__qualname__", function_name)
    return delete

def create_activate_function(model_name=None, Model=None):
    my_columns = Model.__table__.columns

    def activate(db: Session, target_id=None, edited_by=None):
        returnable = False
        if not target_id: return False
        if not edited_by: return False
        try: exists = db.query(Model). \
                    filter(Model.id==target_id). \
                    filter(Model.bln_active==False). \
                    one()
        except: exists = False
        if not exists: return False
        db_record = exists
        db_record.bln_active = True
        db_record.bln_edited = True
        db_record.edited_by = edited_by
        db.add(db_record)
        if db_record: returnable = db_record.__dict__
        try: db.commit()
        except: db.rollback()
        finally:
            db.flush()
            db.close()
        return returnable

    model_name = model_name[:-4]
    function_name = f"activate_{model_name.lower()}"
    setattr(activate, "__name__", function_name)
    setattr(activate, "__qualname__", function_name)
    return activate

def create_read_by_id_function(model_name=None, Model=None):

    def get_by_id(db: Session, target_id: int, target_column: str = None):
        if not target_id: return False
        db_record = db.query(Model). \
                filter(Model.bln_active==True)

        if target_column:
            if hasattr(Model, target_column): db_record = db_record.filter(getattr(Model, target_column)==target_id)
        else: db_record = db_record.filter(Model.id==target_id)

        db_record = db_record.first()
        returnable = get_returnable_dict(db_record)
        db.close()
        return returnable
    
    function_name = f"get_{model_name.lower()}_by_id"
    setattr(get_by_id, "__name__", function_name)
    setattr(get_by_id, "__qualname__", function_name)
    return get_by_id

def create_read_all_function(model_name=None, Model=None):
    def get_all(db:Session, validator: Optional[SearchValidator] = None):
        default_validator = SearchValidator()

        limit = default_validator.limit
        sort_direction = sort_order_dict.get(default_validator.sort_direction)
        sort_on = default_validator.sort_on
        if not hasattr(Model, sort_on): return False
        sort_column = getattr(Model, sort_on)

        if not validator:
            db_record = db.query(Model). \
                filter(Model.bln_active==True)

        else:
            if validator.searchphrase: 
                column_exclusions_list = ['added_by', 'edited_by']
                searchphrase = f"%{validator.searchphrase}%"

                search_columns = []
                for column in Model.__table__.columns:
                    column_type = column.type
                    python_type = column_type.python_type
                    if python_type != str: continue
                    column_filter = getattr(Model, str(column.name))
                    search_columns.append(column_filter)

                db_record = db.query(Model). \
                        filter(or_(*[col.ilike(searchphrase) for col in search_columns]))

            else:
                db_record = db.query(Model). \
                    filter(Model.bln_active==True)

            if validator.sort_direction: 
                if sort_order_dict.get(validator.sort_direction): sort_direction = sort_order_dict.get(validator.sort_direction)
            if validator.sort_on: sort_on = validator.sort_on
            if not hasattr(Model, sort_on): return False
            sort_column = getattr(Model, sort_on)

        db_record = db_record.order_by(sort_direction(sort_column)). \
                limit(limit). \
                all()

        returnable = False
        if db_record and isinstance(db_record, list): returnable = [item for item in db_record]
        db.close()
        return returnable

    function_name = f"get_all_{model_name.lower()}"
    setattr(get_all, "__name__", function_name)
    setattr(get_all, "__qualname__", function_name)
    return get_all

def create_all_string_attribute_funcs(model_name, Model, column_name, python_type):
    string_func_dict = {}
    def get_get_all_where():

        def get_all_where(db: Session, value: python_type, limit: int = LIMIT):
            active_filter = getattr(Model, column_name)
            db_record = db.query(Model). \
                    filter(Model.bln_active==True). \
                    filter(active_filter==value). \
                    limit(limit). \
                    all()

            returnable = False
            if db_record and isinstance(db_record, list): returnable = [item for item in db_record]
            db.close()
            return returnable

        setattr(get_all_where, "__name__", f"get_all_{model_name.lower()}_where_{column_name.lower()}")
        setattr(get_all_where, "__qualname__", f"get_all_{model_name.lower()}_where_{column_name.lower()}")
        return get_all_where

    def get_get_first_where():
        def get_first_where(db: Session, value: python_type):
            active_filter = getattr(Model, column_name)
            db_record = db.query(Model). \
                    filter(Model.bln_active==True). \
                    filter(active_filter==value). \
                    first()

            returnable = False
            if db_record and isinstance(db_record, list): returnable = [item for item in db_record]
            db.close()
            return returnable

        setattr(get_first_where, "__name__", f"get_first_{model_name.lower()}_where_{column_name.lower()}")
        setattr(get_first_where, "__qualname__", f"get_first_{model_name.lower()}_where_{column_name.lower()}")
        return get_first_where

        attribute_func_dict[f'get_first_{model_name.lower()}_where_{column_name.lower()}'] = get_first_where

    string_func_dict[f'get_all_{model_name.lower()}_where_{column_name.lower()}'] = get_get_all_where()
    string_func_dict[f'get_first_{model_name.lower()}_where_{column_name.lower()}'] = get_get_first_where()
    #string_func_dict[column_name] = get_get_all_where()
    return string_func_dict

def create_get_all_by_attribute_function(model_name=None, Model=None):
    if not model_name or not Model: return False
    attribute_func_dict = {}
    for column in Model.__table__.columns:
        column_func_dict = {}

        column_type = column.type
        column_name = column.name
        python_type = column_type.python_type

        int_grouping = [int, Decimal, date, time, datetime]
        if python_type in int_grouping: 
            int_func_dict = create_all_int_attribute_funcs(model_name, Model, column_name, python_type)
            column_func_dict.update(int_func_dict)
        elif python_type == str: 
            string_func_dict = create_all_string_attribute_funcs(model_name, Model, column_name, python_type)
            column_func_dict.update(string_func_dict)

        def get_get_by_attribute_all():
            def get_by_attribute_all(db:Session, value: python_type, limit: int = LIMIT):
                if not value: return False
                active_filter = getattr(Model, column_name)
                db_record = db.query(Model). \
                        filter(Model.bln_active==True). \
                        filter(active_filter==value). \
                        limit(limit). \
                        all()
                if db_record and isinstance(db_record, list): returnable = [item for item in db_record]
                returnable = get_returnable_list_dict(db_record)
                db.close()
                return returnable

            setattr(get_by_attribute_all, "__name__", f"get_all_{model_name.lower()}_by_{column_name.lower()}")
            setattr(get_by_attribute_all, "__qualname__", f"get_all_{model_name.lower()}_by_{column_name.lower()}")
            return get_by_attribute_all

        setattr(get_get_by_attribute_all, "__name__", f"get_get_all_{model_name.lower()}_by_{column_name.lower()}")
        setattr(get_get_by_attribute_all, "__qualname__", f"get_get_all_{model_name.lower()}_by_{column_name.lower()}")
        column_func_dict[f'get_all_{model_name.lower()}_where_{column_name.lower()}'] = get_get_by_attribute_all()

        get_first_where_attribute_func = create_get_first_where_attribute(Model, model_name, column_name, python_type)
        column_func_dict[f'get_first_{model_name.lower()}_where_{column_name.lower()}'] = get_first_where_attribute_func

        attribute_func_dict[str(column_name)] = column_func_dict.copy()

    return attribute_func_dict

def create_get_first_where_attribute(Model=None, model_name=None, column_name=None, python_type=None):
    if not any([Model, model_name, column_name, python_type]): return False

    def get_get_first_where_attribute():
        def get_first_where_attribute(db:Session, value: python_type):
            if not value: return False
            active_filter = getattr(Model, column_name)
            db_record = db.query(Model). \
                    filter(Model.bln_active==True). \
                    filter(active_filter==value). \
                    first()
            returnable = {} 
            if db_record: returnable = get_returnable_dict(db_record)
            db.close()
            return returnable

        setattr(get_first_where_attribute, "__name__", f"get_first_{model_name.lower()}_where_{column_name.lower()}")
        setattr(get_first_where_attribute, "__qualname__", f"get_first_{model_name.lower()}_where_{column_name.lower()}")
        return get_first_where_attribute
    return get_get_first_where_attribute()

def generate_controller_cruds(controller_name=None, controller_db_dict=None, tables=None):
    if not controller_name or not controller_db_dict or not tables: return False
    controller_cruds = {}
    kwargs = {}
    if not tables: return False
    for table_name, table in tables.items():
        cruds_dict = {}
        kwargs['model_name'] = table_name
        kwargs['Model'] = table

        all_attrs_funcs = create_get_all_by_attribute_function(**kwargs)
        for column_name, column_funcs_dict in all_attrs_funcs.items():
            cruds_dict.update(column_funcs_dict)

        create = create_create_function(**kwargs)
        cruds_dict['create'] = create

        update = create_update_function(**kwargs)
        cruds_dict['update'] = update

        delete = create_delete_function(**kwargs)
        cruds_dict['delete'] = delete

        activate = create_activate_function(**kwargs)
        cruds_dict['activate'] = activate

        deactivate = create_deactivate_function(**kwargs)
        cruds_dict['deactivate'] = deactivate

        get_by_id = create_read_by_id_function(**kwargs)
        cruds_dict['get_by_id'] = get_by_id

        get_all = create_read_all_function(**kwargs)
        cruds_dict['get_all'] = get_all

        controller_cruds[table_name.lower()] = cruds_dict
    return controller_cruds

def get_returnable_dict(sqlaresult=None):
    if sqlaresult:
        print("I am")
        print(dir(sqlaresult))
        if hasattr(sqlaresult, "__dict__"):
            print("here")
            returnable = {k:v for k,v in sqlaresult.__dict__.items() if not k.startswith("_")}
            return returnable
    return False

def get_returnable_list_dict(sqlaresult=None):
    if sqlaresult:
        if isinstance(sqlaresult, list):
            returnable = [get_returnable_dict(item) for item in sqlaresult]
            return returnable
    return False
