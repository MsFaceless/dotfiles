#!/bin/python
# -*- coding: utf-8 -*-

from abc import ABC, abstractmethod, abstractclassmethod
from typing import List, Union

from dotenv import dotenv_values

from twilio.rest import Client

env_vars = dotenv_values()
ACCOUNT_SID = env_vars.get('ACCOUNT_SID', None)
AUTH_TOKEN = env_vars.get('AUTH_TOKEN', None)
TWILIO_NUMBER = env_vars.get('TWILIO_NUMBER', None)
WHATSAPP_NUMBER = env_vars.get('WHATSAPP_NUMBER', None)

ACCOUNT_SID='AC6f24bb09cd31f8551d565514568a817f'
AUTH_TOKEN='5f24b8949df9696f60416fc922f86484'
MESSAGING_SID='MG5e0bc68cd8dfb289560c29e6b4bb0064'
#TWILIO_NUMBER='+19362367906'
TWILIO_NUMBER='+15005550006'
WHATSAPP_NUMBER='+14155238886'

class AbstractEvent(ABC):
    @abstractclassmethod
    def _log_event_api(
        cls, sender: str, reciever: str, message_type: str, success: bool
    ):
        raise NotImplementedError("Abstract event not implemented")

    @classmethod
    def log_event(cls, sender: str, reciever: str, message_type: str, success: bool):
        cls._log_event_api(sender, reciever, message_type, success)

class AbstractMessenger(ABC):
    """
    Abstract class that provides a generic way of sending messages via an API
    """

    type = "Not implemented"
    loggers: List[AbstractEvent] = []

    @classmethod
    @abstractmethod
    def _send_message_via_api(
        cls, source: str, destination: Union[str, List[str]], message: str
    ) -> (bool, str):
        """Abstract method that needs to be implemented with a specific API.
        Args:
            source (str): A string describing where message came from
            destination (str|Array[str]): A string or array of strings of destinations
            message (str): A string containing the message to be sent
        Returns:
            (bool, str): A tuple containing whether message was sent successfully or not
        Raises:
            NotImplementedError: [description]
        """

        pass

    @classmethod
    def send_message_from_content(cls, content):
        """Helper class that verifies the dictionary's content, then
        sends a messae

        Args:
            content (dict): A dictionary containing the source, destination and
            content for a message

        Returns:
           (bool, str): A tuple containing whether message was sent successfully or not
        """

        try:

            assert "source" in content.keys(), "source value not supplied"
            assert "destination" in content.keys(), "destination value not supplied"
            assert "message" in content.keys(), "message value not supplied"

            return cls.send_message(
                content["source"], content["destination"], content["message"]
            )
        except Exception as e:
            return (False, str(e))

    @classmethod
    def send_message(
        cls, source: str, destination: Union[str, List[str]], message: str
    ) -> (bool, str):
        """Concrete class that runs the api call, then logs the event using a registered logger
        Args:
            source (str): The source of the message
            destination (str|Array[str]): The destination or destinations of the message
            message (str): The message
        Returns:
            bool, str: a boolean indicating whether the message was sent and an
             error if necessary
        """

        (success, error) = cls._send_message_via_api(source, destination, message)

        for logger in cls.loggers:

            if type(destination) is list:
                # If there is more than one destination, we log them seperately
                for d in destination:

                    logger.log_event(source, d, cls.type, success)
            else:
                logger.log_event(source, destination, cls.type, success)
        return success, error

    @classmethod
    def register_logger(cls, logger: AbstractEvent):
        """Registers a logger to this class

        Args:
            logger (AbstractEvent): An abstract event logger
        """

        cls.loggers.append(logger)

    @classmethod
    def remove_logger(cls, logger: AbstractEvent):
        try:
            cls.loggers.remove(logger)
        # If there isn't a logger to remove, we don't have to worry about throwing an
        # error.
        except ValueError:
            pass

class SMSMessenger(AbstractMessenger):
    @classmethod
    def _send_message_via_api(cls, source, destination, message):

        try:
            cls.type = "sms"
            client = Client(ACCOUNT_SID, AUTH_TOKEN)
            assert len(message) < 160, "Message needs to be less than 160 characters"
            client.messages.create(
                from_=TWILIO_NUMBER,
                body="{}".format(message),
                to="{}".format(destination),
            )

            return (True, "")
        except Exception as e:
            return (False, str(e))

class WhatsappMessenger(AbstractMessenger):
    @classmethod
    def _send_message_via_api(cls, source, destination, message):
        try:
            client = Client(ACCOUNT_SID, AUTH_TOKEN)
            client.messages.create(
                from_="whatsapp:{}".format(WHATSAPP_NUMBER),
                body="{}".format(message),
                to="whatsapp:{}".format(destination),
            )

            return (True, "")
        except Exception as e:
            return (False, str(e))
