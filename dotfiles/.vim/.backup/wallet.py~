# -*- coding: utf-8 -*-
"""Wallet Controller"""

import math
import logging
from sqlalchemy import desc, or_
from tg import expose, request

from calabash import model
from calabash.model import *

from calabash.lib.html_utils import *
from calabash.lib.base import BaseController
from calabash.lib.type_utils import TypeDictionary
from calabash.lib.tg_decorators import safe_headers, time_it
from calabash.lib.myimali_api_gateway import MyImaliApiGateway
from calabash.lib.netcash_api_gateway import NetcashApiGateway
from calabash.lib.email_creator import CalabashCampusEmailCreator

from calabash.controllers.common import CommonController
from calabash.controllers.registration import RegistrationController

import calabash.lib.vault_utils as VAULT
import calabash.lib.nchan_utils as NCHAN

GET_HISTORY_LIMIT = 100
FROM_DATE_DAYS_AGO = 30

MYIMALI = MyImaliApiGateway()
NETCASH = NetcashApiGateway()
COMMON = CommonController()
REGISTRATION = RegistrationController()

TYPEDICT = TypeDictionary()
ACCEPTED = TYPEDICT.get_id_of_name('notification_type', 'accepted')
REJECTED = TYPEDICT.get_id_of_name('notification_type', 'rejected')
MAKE_SALE = TYPEDICT.get_id_of_name('notification_type', 'make_sale')
FEATURED_AD = TYPEDICT.get_id_of_name('notification_type', 'featured_ad')
PENDING_SALE = TYPEDICT.get_id_of_name('notification_type', 'pending_sale')
GROUP_INVITE = TYPEDICT.get_id_of_name('notification_type', 'group_invite')

LOGGER = logging.getLogger(__name__)

class WalletController(BaseController):

    @safe_headers
    @expose('json')
    def get_banking_config(self, *args, **kwargs):
        result = MYIMALI.get_banking_config(**kwargs)
        success = result.get('success', False)
        if not success:
            return error_response('Could not retrieve banking config.')
        return result

    @safe_headers
    @expose('json')
    def add_banking_details(self, *args, **kwargs):
        username = kwargs.get('username', None)
        if not username:
            return error_response('No username supplied.')

        account = UsernameAccountLink.by_attr_first('username', username)
        if account:
            return success_response(str(account.account_id))

        result = MYIMALI.add_banking_details(**kwargs)
        success = result.get('success', False)
        if not success:
            error = result.get('error', '')
            if not error:
                error = result.get('message', '')
            transfer_result = COMMON.auto_transfer_user_api_key(error, username)
            if transfer_result:
                return self.add_banking_details(**kwargs)
            return error_response(error)

        data = result.get('data', {})
        account_id = data.get('vAccountId', None)

        account = UsernameAccountLink()
        account.username = username
        account.account_id = account_id
        DBSession.add(account)
        DBSession.flush()
        return success_response(str(account.account_id))

    @safe_headers
    @expose('json')
    def delete_banking_details(self, *args, **kwargs):
        username = kwargs.get('username', None)
        if not username:
            return error_response('No username supplied.')

        account_id = kwargs.get('account_id', None)
        if not account_id:
            return error_response('No account_id supplied.')

        result = MYIMALI.delete_banking_details(**kwargs)
        success = result.get('success', False)
        if not success:
            error = result.get('error', '')
            if not error:
                error = result.get('message', '')
            transfer_result = COMMON.auto_transfer_user_api_key(error, username)
            if transfer_result:
                return self.delete_banking_details(**kwargs)
            return error_response(error)

        exists = UsernameAccountLink.by_attr_first('account_id', account_id)
        if exists:
            exists.active = False
            DBSession.flush()

        return success_response('True')

    @safe_headers
    @expose('json')
    def payout_to_account(self, *args, **kwargs):
        username = kwargs.get('username', None)
        if not username:
            return error_response('No username supplied.')

        account = UsernameAccountLink.by_attr_first('username', username)
        if not account:
            return error_response('No account_id for username.')

        kwargs['account_id'] = account.account_id
        result = MYIMALI.payout_to_account(**kwargs)
        success = result.get('success', False)
        if not success:
            error = result.get('error', '')
            transfer_result = COMMON.auto_transfer_user_api_key(error, username)
            if transfer_result:
                return self.payout_to_account(**kwargs)
            return error_response(error)
        return success_response('True')

    @safe_headers
    @expose('json')
    def payout_to_multiple_accounts(self, *args, **kwargs):
        username = kwargs.get('username', None)
        if not username:
            return error_response('No username supplied.')

        data = kwargs.get('data', [])
        if not data:
            return error_response('No data supplied.')

        outputlist = []
        for item in data:

            if isinstance(item, str):
                continue

            account_id = item.get('account_id', None)

            exists = DBSession.query(UsernameAccountLink). \
                    filter(UsernameAccountLink.username == username). \
                    filter(UsernameAccountLink.account_id == account_id). \
                    filter(UsernameAccountLink.active == True). \
                    first()

            if not exists:
                itemdict = {'success' : False,
                            'account_id' : account_id,
                            'error' : 'No account for account_id.', }

            else:
                kwargs = {'username' : username,
                          'account_id' : account_id,
                          'amount' : item.get('amount', None), }
                result = MYIMALI.payout_to_account(**kwargs)
                success = result.get('success', False)
                if not success:
                    error = result.get('error', '')
                    itemdict = {'success' : False,
                                'account_id' : account_id,
                                'error' : error, }
                else:
                    itemdict = {'success' : True,
                                'account_id' : account_id,
                                'error' : None, }
            outputlist.append(itemdict)
        return success_response(outputlist)

    @safe_headers
    @expose('json')
    def get_banking_details(self, *args, **kwargs):
        username = kwargs.get('username', None)
        if not username:
            return error_response('No username supplied.')

        result = MYIMALI.get_banking_details(**kwargs)
        success = result.pop('success', False)
        if not success:
            error = result.get('error', '')
            transfer_result = COMMON.auto_transfer_user_api_key(error, username)
            if transfer_result:
                return self.get_banking_details(kwargs)
            return error_response(error)

        outputlist = []
        data = result.get('data', [])
        for item in data:
            item.pop('vAPIUsername', '')

            account_id = item.get('vAccountId', None)
            exists = DBSession.query(UsernameAccountLink). \
                    filter(UsernameAccountLink.username == username). \
                    filter(UsernameAccountLink.account_id == account_id). \
                    filter(UsernameAccountLink.active == True). \
                    first()
            if not exists:
                account = UsernameAccountLink()
                account.username = username
                account.account_id = account_id
                DBSession.add(account)
                DBSession.flush()
            outputlist.append(item)
        return success_response(outputlist)

    @safe_headers
    @expose('json')
    def make_mobile_transfer(self, *args, **kwargs):
        to_mobile_number = kwargs.get('to_mobile_number', None)
        if not to_mobile_number:
            return error_response('To mobile number not found.')

        result = VAULT.get_entity_by_mobile({'mobile_number' : to_mobile_number})
        print(result)
        return error_response()
        if not result:
            return error_response('No username for mobile')

        to_username = None
        identity_list = result.get('identity_list', [])
        for identity in identity_list:
            identity_name = identity.get('identitytype', {}).get('name', '').lower()
            if str(identity_name) == 'username':
                to_username = identity.get('value', '')

        if not to_username:
            return error_response(f'No username for {to_mobile_number}')
        kwargs['to_username'] = to_username
        return self.make_user_transfer(**kwargs)

    @safe_headers
    @expose('json')
    def refund_user_from_merchant(self, *args, **kwargs):
        LOGGER.info('refund_user_from_merchant')
        LOGGER.info(str(kwargs))

        from_username = kwargs.get('fromUsername', None)
        if not from_username:
            from_username = kwargs['fromUsername'] = kwargs.get('merchant_username', None)
        if not from_username:
            return error_response('No from username')

        to_username = kwargs.get('toUsername', None)
        if not to_username:
            to_username = kwargs['toUsername'] = kwargs.get('refund_username', None)
        if not to_username:
            return error_response('No to username')

        result = MYIMALI.user_refund(**kwargs)
        success = result.get('success', False)
        if not success:
            error = result.get('error', '')
            transfer_result = COMMON.auto_transfer_user_api_key(error, from_username, call_from_refund=True)
            if transfer_result:
                return self.refund_user_from_merchant(**kwargs)
            return error_response(error)

        self.send_refund_success_notification(**kwargs)
        REGISTRATION.update_transaction_history(**kwargs)
        return success_response('True')

    @safe_headers
    @expose('json')
    @time_it
    def make_user_transfer(self, *args, **kwargs):

        to_username = kwargs.get('to_username', None)
        to_reference = kwargs.get('to_reference', None)
        if not to_username and not to_reference:
            return error_response('Nothing to identify to user.')

        if to_username and not to_reference:
            kwargs['to_reference'] = to_reference = self.get_reference_from_username(to_username)

        if to_reference and not to_username:
            kwargs['to_reference'] = to_reference
            kwargs['to_username'] = to_username = self.get_username_from_reference(to_reference)

        if not to_reference or not to_username:
            return error_response('Failed to find username and reference.')

        result = MYIMALI.make_transfer(**kwargs)
        success = result.get('success', False)
        if not success:
            error = result.get('error', '')
            return error_response(error)

        amount = kwargs.get('amount', '')
        kwargs['to_fullname'] = self.send_transfer_success_notification(**kwargs)
        self.send_transfer_success_email(**kwargs)
        REGISTRATION.update_transaction_history(**kwargs)
        return success_response(str(amount))

    def get_token_from_balance(self, *args, **kwargs):
        result = MYIMALI.get_balance(**kwargs)
        success = result.get('success', False)
        if not success:
            error = result.get('error', '')

            username = kwargs.get('username', None)
            transfer_result = COMMON.auto_transfer_user_api_key(error, username)
            if transfer_result:
                return self.get_token_from_balance(**kwargs)

            return error_response(error)

        token = None
        datalist = result.get('data', [])
        for item in datalist:
            name = item.get('name', '')
            name = name.lower()
            name = str(name)
            if name == 'imali':
                token = item.get('token', None)
        return token

    def get_cashback_percentage_from_merchant_username(self, *args, **kwargs):
        merchant_username = kwargs.get('merchant_username', None)
        if not merchant_username:
            return None

        wallet = Wallet.by_attr_first('username', merchant_username)
        if not wallet:
            return None

        reward_program = MerchantRewardProgram.by_attr_first('wallet_id', wallet.id)
        if not reward_program:
            return None

        if not reward_program.percentage:
            return None

        return reward_program.percentage

    @safe_headers
    @expose('json')
    @time_it
    def make_merchant_sale(self, *args, **kwargs):
        LOGGER.info('make_merchant_sale')
        LOGGER.info(f'{kwargs}')

        token = self.get_token_from_balance(**kwargs)
        if not token:
            return error_response('Unable to get token.')
        kwargs['token'] = token

        merchant_username = kwargs.get('merchant_username', None)
        merchant_reference = kwargs.get('merchant_reference', None)
        if not merchant_username and not merchant_reference:
            return error_response('Nothing to identity merchant.')

        if merchant_username and not merchant_reference:
            kwargs['merchant_reference'] = merchant_reference = self.get_reference_from_username(merchant_username)

        if merchant_reference and not merchant_username:
            kwargs['merchant_reference'] = merchant_reference
            kwargs['merchant_username'] = merchant_username = self.get_username_from_reference(merchant_reference)

        if not merchant_username or not merchant_reference:
            return error_response('Failed to find username and reference.')

        cashback_percentage = self.get_cashback_percentage_from_merchant_username(**kwargs)
        if cashback_percentage:
            kwargs['cashback_percentage'] = cashback_percentage

        result = MYIMALI.make_merchant_sale(**kwargs)
        success = result.get('success', False)
        if not success:
            error = result.get('error', '')

            username = kwargs.get('username', None)
            transfer_result = COMMON.auto_transfer_user_api_key(error, username)
            if transfer_result:
                return self.make_merchant_sale(**kwargs)

            merchant_username = kwargs.get('merchant_username', None)
            transfer_result = COMMON.auto_transfer_user_api_key(error, merchant_username)
            if transfer_result:
                return self.make_merchant_sale(**kwargs)

            return error_response(error)

        amount = kwargs.get('amount', '')
        kwargs['merchant_fullname'] = self.send_sale_success_notification(**kwargs)
        #self.send_sale_success_email(**kwargs)

        REGISTRATION.update_transaction_history(**kwargs)
        return success_response('Sale successful.')

    def get_reference_from_username(self, username=None, *args, **kwargs):
        if not username:
            return False

        wallet = Wallet.by_attr_first('username', username)
        if not wallet:
            return False

        return wallet.myimali_reference

    def get_username_from_reference(self, reference=None, *args, **kwargs):
        if not reference:
            return False

        wallet = Wallet.by_attr_first('myimali_reference', reference)
        if not wallet:
            return False

        return wallet.username

    @safe_headers
    @expose('json')
    def save_merchant_reward(self, *args, **kwargs):
        merchant_username = kwargs.get('merchant_username', None)
        if not merchant_username:
            return error_response('merchant_username not found')

        percentage = kwargs.get('percentage', None)
        if not percentage:
            return error_response('percentage not found')

        wallet = Wallet.by_attr_first('username', merchant_username)
        if not wallet:
            return error_response('No wallet for username')

        program = MerchantRewardProgram.by_attr_first('wallet_id', wallet.id)
        if program:
            program.percentage = percentage
            DBSession.flush()
        else:
            program = MerchantRewardProgram()
            program.wallet_id = wallet.id
            program.percentage = percentage
            DBSession.add(program)
            DBSession.flush()
        return success_response('True')

    @safe_headers
    @expose('json')
    def get_transaction_type_list(self, *args, **kwargs):
        LOGGER.info('get_transaction_type_list')
        LOGGER.info(str(kwargs))
        username = kwargs.get('username', None)

        if username:
            dbase_query = DBSession.query(TransactionHistory). \
                filter(or_(
                    TransactionHistory.username == username,
                    TransactionHistory.other == username,
                )). \
                order_by(TransactionHistory.type.asc()). \
                group_by(TransactionHistory.type). \
                all()
        else:
            dbase_query = DBSession.query(TransactionHistory). \
                order_by(TransactionHistory.type.asc()). \
                group_by(TransactionHistory.type). \
                all()
        outputlist = [x.type for x in dbase_query]
        return success_response(outputlist)

    @safe_headers
    @expose('json')
    def get_paginated_transaction_history(self, *args, **kwargs):
        LOGGER.info('get_paginated_transaction_history')
        LOGGER.info(str(kwargs))

        to_date = kwargs.get('to_date', None)
        username = kwargs.get('username', None)
        from_date = kwargs.get('from_date', None)
        search_phrase = kwargs.get('search_phrase', '')
        coupon_type = kwargs.get('coupon_type', 'iMali')
        transaction_type = kwargs.get('transaction_type', '')

        if not username:
            return error_response('No username supplied.')

        dbase_query = DBSession.query(TransactionHistory). \
            filter(TransactionHistory.username == username). \
            filter(TransactionHistory.coupon_type == coupon_type)

        if transaction_type:
            dbase_query = dbase_query.filter(TransactionHistory.type == transaction_type)

        if from_date:
            search_date = str_to_date(from_date)
            if not search_date:
                search_date = str_to_date(from_date, '%Y-%m-%d')
            if search_date:
                dbase_query = dbase_query.filter(TransactionHistory.datetime >= search_date)

        if to_date:
            search_date = str_to_date(to_date)
            if not search_date:
                search_date = str_to_date(to_date, '%Y-%m-%d')
            if search_date:
                search_date = search_date.replace(hour=23, minute=59, second=59)
                dbase_query = dbase_query.filter(TransactionHistory.datetime <= search_date)

        if search_phrase:
            search_phrase = '%' + search_phrase + '%'
            dbase_query = dbase_query.filter(or_(
                    TransactionHistory.TrxId.like(search_phrase),
                    TransactionHistory.other.like(search_phrase),
                ))

        dbase_query = dbase_query. \
            order_by(TransactionHistory.datetime.desc())

        kwargs['query'] = dbase_query
        return self.paginate(**kwargs)

    def paginate(self, *args, **kwargs):
        try:
            page = int(kwargs.get('page', 1))
        except:
            return error_response('Could not int page.')

        try:
            page_size = int(kwargs.get('page_size', 10))
        except:
            return error_response('Could not int page_size.')

        query = kwargs.get('query', [])
        if not query:
            return error_response('No query present.')

        if page <= 0:
            return error_response('Page cannot be 0 or less.')

        if page_size <= 0:
            return error_response('Page size cannot be 0 or less.')

        offset = (page - 1) * page_size
        items = query.limit(page_size).offset(offset).all()
        total = query.order_by(None).count()

        previous_page = None
        has_previous = page > 1
        if has_previous:
            previous_page = page - 1

        previous_items = (page - 1) * page_size

        next_page = None
        has_next = previous_items + len(items) < total
        if has_next:
            next_page = page + 1

        pages = int(math.ceil(total / float(page_size)))

        outputdict = {
            'items': items,
            'total': total,
            'current_page': page,
            'pages': pages,
            'has_previous': has_previous,
            'previous_page': previous_page,
            'has_next': has_next,
            'next_page': next_page,
        }
        return success_response(outputdict)

    @safe_headers
    @expose('json')
    def get_transaction_history(self, *args, **kwargs):
        kwargs['coupon_type'] = 'iMali'
        REGISTRATION.update_transaction_history(**kwargs)
        return self.get_generic_transaction_history(**kwargs)

    @safe_headers
    @expose('json')
    def get_loyalty_transaction_history(self, *args, **kwargs):
        kwargs['coupon_type'] = 'iMali-Loyalty'
        REGISTRATION.update_transaction_history(**kwargs)
        return self.get_generic_transaction_history(**kwargs)

    @safe_headers
    @expose('json')
    def get_savings_transaction_history(self, *args, **kwargs):
        kwargs['coupon_type'] = 'iMali-Savings'
        REGISTRATION.update_transaction_history(**kwargs)
        return self.get_generic_transaction_history(**kwargs)

    def get_generic_transaction_history(self, *args, **kwargs):
        coupon_type = kwargs.get('coupon_type', None)
        if not coupon_type:
            return error_response('No coupon_type supplied.')

        username = kwargs.get('username', None)
        if not username:
            return error_response('No username supplied.')

        limit = kwargs.get('limit', GET_HISTORY_LIMIT)

        dbase_query = DBSession.query(TransactionHistory). \
                filter(TransactionHistory.coupon_type == coupon_type). \
                filter(TransactionHistory.username == username). \
                filter(TransactionHistory.amount != 0). \
                order_by(TransactionHistory.datetime.desc()). \
                limit(limit)

        outputlist = []
        for item in dbase_query:

            other = str(item.other).title()
            if other == 'Imali':
                other = 'Main'
            if other == 'Imali-Savings':
                other = 'Savings'
            if other == 'Imali-Loyalty':
                other = 'Loyalty'

            outputdict = {
                'date' : item.date,
                'time' : item.time,
                'seconds' : item.seconds,
                'datetime' : item.datetime,
                'type' : item.type,
                'amount' : int(item.amount),
                'balance' : item.balance,
                'other' : other,
                'TrxId' : item.TrxId,
                'paymentReference' : item.paymentReference,
            }
            outputlist.append(outputdict)
        return success_response(outputlist)

    @safe_headers
    @expose('json')
    def get_transaction_refund_options(self, *args, **kwargs):
        result = MYIMALI.get_transaction_refund_options(**kwargs)
        success = result.get('success', False)
        if not success:
            error = result.get('error', '')
            return error_response(error)
        return success_response(result)

    @safe_headers
    @expose('json')
    def get_balance(self, *args, **kwargs):
        username = kwargs.get('username', None)
        if not username:
            return error_response('get_balance failed: username not found')

        result = MYIMALI.get_balance(**kwargs)
        success = result.get('success', False)
        if not success:
            error = result.get('error', '')
            transfer_result = COMMON.auto_transfer_user_api_key(error, username)
            if transfer_result:
                return self.get_balance(**kwargs)
            return error_response(error)

        outputdict = {}
        datalist = result.get('data', [])
        for item in datalist:
            name = item.get('name', '')
            name = name.lower()
            name = str(name)

            if name == 'imali':
                balance_in_cents = item.get('balance', 0)
                balance_in_rands = balance_in_cents / 100
                balance_in_rands = "{:.2f}".format(balance_in_rands)

                outputdict['balance'] = balance_in_rands
                outputdict['balance_in_cents'] = balance_in_cents

            if name == 'imali-loyalty':
                balance_in_cents = item.get('balance', 0)
                balance_in_rands = balance_in_cents / 100
                balance_in_rands = "{:.2f}".format(balance_in_rands)

                outputdict['loyalty_balance'] = balance_in_rands
                outputdict['loyalty_balance_in_cents'] = balance_in_cents

            if name == 'imali-savings':
                balance_in_cents = item.get('balance', 0)
                balance_in_rands = balance_in_cents / 100
                balance_in_rands = "{:.2f}".format(balance_in_rands)

                outputdict['savings_balance'] = balance_in_rands
                outputdict['savings_balance_in_cents'] = balance_in_cents

        loyalty_balance = outputdict.get('loyalty_balance', None)
        if not loyalty_balance:
            outputdict['loyalty_balance'] = '0.00'
            outputdict['loyalty_balance_in_cents'] = 0

        savings_balance = outputdict.get('savings_balance', None)
        if not savings_balance:
            outputdict['savings_balance'] = '0.00'
            outputdict['savings_balance_in_cents'] = 0

        return success_response([outputdict])

    @safe_headers
    @expose('json')
    def transfer_main_to_savings(self, *args, **kwargs):
        username = kwargs.get('username', None)
        if not username:
            return error_response('No username supplied.')

        result = MYIMALI.transfer_main_to_savings(**kwargs)
        success = result.get('success', False)
        if not success:
            error = result.get('error', '')
            transfer_result = COMMON.auto_transfer_user_api_key(error, username)
            if transfer_result:
                return self.transfer_main_to_savings(**kwargs)
            return error_response(error)

        transaction_id = result.get('transactionId', None)
        if not transaction_id:
            return error_response('Unable to get transaction_id.')

        kwargs['coupon_type'] = 'iMali'
        REGISTRATION.update_transaction_history(**kwargs)
        kwargs['coupon_type'] = 'iMali-Savings'
        REGISTRATION.update_transaction_history(**kwargs)

        return success_response(str(transaction_id))

    @safe_headers
    @expose('json')
    def transfer_savings_to_main(self, *args, **kwargs):
        username = kwargs.get('username', None)
        if not username:
            return error_response('No username supplied.')

        result = MYIMALI.transfer_savings_to_main(**kwargs)
        success = result.get('success', False)
        if not success:
            error = result.get('error', '')
            transfer_result = COMMON.auto_transfer_user_api_key(error, username)
            if transfer_result:
                return self.transfer_savings_to_main(**kwargs)
            return error_response(error)

        transaction_id = result.get('transactionId', None)
        if not transaction_id:
            return error_response('Unable to get transaction_id.')

        kwargs['coupon_type'] = 'iMali'
        REGISTRATION.update_transaction_history(**kwargs)
        kwargs['coupon_type'] = 'iMali-Savings'
        REGISTRATION.update_transaction_history(**kwargs)

        return success_response(str(transaction_id))

    @safe_headers
    @expose('json')
    def transfer_loyalty_to_main(self, *args, **kwargs):
        username = kwargs.get('username', None)
        if not username:
            return error_response('No username supplied.')

        result = MYIMALI.transfer_loyalty_to_main(**kwargs)
        success = result.get('success', False)
        if not success:
            error = result.get('error', '')
            transfer_result = COMMON.auto_transfer_user_api_key(error, username)
            if transfer_result:
                return self.transfer_loyalty_to_main(**kwargs)
            return error_response(error)

        transaction_id = result.get('transactionId', None)
        if not transaction_id:
            return error_response('Unable to get transaction_id.')

        kwargs['coupon_type'] = 'iMali'
        REGISTRATION.update_transaction_history(**kwargs)
        kwargs['coupon_type'] = 'iMali-Loyalty'
        REGISTRATION.update_transaction_history(**kwargs)

        return success_response(str(transaction_id))

    @safe_headers
    @expose('json')
    def transfer_loyalty_to_savings(self, *args, **kwargs):
        username = kwargs.get('username', None)
        if not username:
            return error_response('No username supplied.')

        result = MYIMALI.transfer_loyalty_to_savings(**kwargs)
        success = result.get('success', False)
        if not success:
            error = result.get('error', '')
            transfer_result = COMMON.auto_transfer_user_api_key(error, username)
            if transfer_result:
                return self.transfer_loyalty_to_savings(**kwargs)
            return error_response(error)

        transaction_id = result.get('transactionId', None)
        if not transaction_id:
            return error_response('Unable to get transaction_id.')

        kwargs['coupon_type'] = 'iMali-Savings'
        REGISTRATION.update_transaction_history(**kwargs)
        kwargs['coupon_type'] = 'iMali-Loyalty'
        REGISTRATION.update_transaction_history(**kwargs)

        return success_response(str(transaction_id))

###############################################################################
# create_eiffel_make_sale: accept and reject
###############################################################################

    @safe_headers
    @expose('json')
    def create_eiffel_seller_to_buyer_sale_notification(self, *args, **kwargs):
        LOGGER.info('create_eiffel_seller_to_buyer_sale_notification')
        LOGGER.info(str(kwargs))

        from_entity_id = kwargs.get('from_entity_id', None)
        from_wallet = self.get_wallet_by_entity_id(from_entity_id)
        if not from_wallet:
            return error_response('No from entity_id to notify')

        to_entity_id = kwargs.get('to_entity_id', None)
        to_wallet = self.get_wallet_by_entity_id(to_entity_id)
        if not to_wallet:
            return error_response('No to entity_id to notify')

        amount = kwargs.get('amount', None)
        if not amount:
            return error_response('No amount to notify')

        message = kwargs.get('message', None)
        if not message:
            return error_response("No message or notify")

        application = Application.by_attr_first('name', 'Calabash Mobile')

        kwargs['application_id'] = application.id
        kwargs['to_username'] = to_wallet.username
        kwargs['from_username'] = from_wallet.username
        kwargs['notification_type_id'] = MAKE_SALE
        notification = self.create_notification(**kwargs)

        params = {'id': to_wallet.username}
        data = self.get_notify_dict_by_notification(notification)
        result = NCHAN.publish_to_campus(params, data)
        if result and result.status_code == 200:
            notification.bln_delivered = True
            DBSession.flush()

        notification_type = TYPEDICT.get_pretty_name('notification_type', MAKE_SALE)
        return success_response(str(notification_type))

    @safe_headers
    @expose('json')
    def accept_calabash_campus_make_sale_notification(self, *args, **kwargs):
        LOGGER.info('accept_calabash_campus_make_sale_notification')
        LOGGER.info(str(kwargs))

        notification_id = kwargs.get('notification_id', None)
        if not notification_id:
            return error_response('No notification_id')

        notification = Notification.by_id(notification_id)
        if not notification:
            return error_response('No notification for id')

        notification.bln_actioned = True
        DBSession.flush()

        user_transfer_kwargs = {
            'from_username' : notification.to_username, # Swapped deliberately
            'to_username' : notification.from_username, # Swapped deliberately
            'amount' : notification.amount,
            'reference' : notification.message,
        }
        result = self.make_user_transfer(**user_transfer_kwargs)
        success = result.get('success', False)

        # As per JP: 30 June 2020
        to_user = REGISTRATION.get_user_profile(**{'username' : notification.to_username})
        data = to_user.get('data', {})
        to_name = data.get('name', '')
        to_surname = data.get('surname', '')

        if not success:
            reason = result.get('data', '')
            buyer_template = MessageTemplate.by_attr_first('usage', 'Mobile Buyer Make Sale Accepted Failure')
            buyer_message = buyer_template.message.format(**locals())

            seller_template = MessageTemplate.by_attr_first('usage', 'Mobile Seller Make Sale Accepted Failure')
            seller_message = seller_template.message.format(**locals())

        else:
            buyer_template = MessageTemplate.by_attr_first('usage', 'Mobile Buyer Make Sale Accepted Success')
            buyer_message = buyer_template.message.format(**locals())

            seller_template = MessageTemplate.by_attr_first('usage', 'Mobile Seller Make Sale Accepted Success')
            seller_message = seller_template.message.format(**locals())

        mobile_application = Application.by_attr_first('name', 'Calabash Mobile')

        # Notify the buyer in mobile of the result of accepting
        kwargs['application_id'] = mobile_application.id
        kwargs['notification_type_id'] = ACCEPTED
        kwargs['to_username'] = notification.to_username
        kwargs['from_username'] = notification.from_username
        kwargs['message'] = buyer_message # TODO: reject notification message is hardcoded
        kwargs['amount'] = notification.amount
        kwargs['actioned_notification_id'] = notification_id
        buyer_notification = self.create_notification(**kwargs)

        params = {'id': buyer_notification.to_username}
        data = self.get_notify_dict_by_notification(buyer_notification)
        result = NCHAN.publish_to_campus(params, data)
        if result and result.status_code == 200:
            this.bln_delivered = True
            DBSession.flush()

        # Notify the seller in mobile of the result of accepting
        kwargs['notification_type_id'] = ACCEPTED
        kwargs['to_username'] = notification.from_username # swapping usernames so it notifies the other party
        kwargs['from_username'] = notification.to_username
        kwargs['message'] = seller_message # TODO: reject notification message is hardcoded
        kwargs['amount'] = notification.amount
        kwargs['actioned_notification_id'] = notification.id
        seller_notification = self.create_notification(**kwargs)

        params = {'id': seller_notification.to_username}
        data = self.get_notify_dict_by_notification(seller_notification)
        result = NCHAN.publish_to_campus(params, data)
        if result and result.status_code == 200:
            this.bln_delivered = True
            DBSession.flush()

        # Notify the seller in eiffel of the result of accepting
        eiffel_application = Application.by_attr_first('name', 'Eiffel Corp Marketplace')
        kwargs['application_id'] = eiffel_application.id
        kwargs['notification_type_id'] = ACCEPTED
        kwargs['to_username'] = notification.from_username # swapping usernames so it notifies the other party
        kwargs['from_username'] = notification.to_username
        kwargs['message'] = seller_message # TODO: reject notification message is hardcoded
        kwargs['amount'] = notification.amount
        kwargs['actioned_notification_id'] = notification.id
        eiffel_notification = self.create_notification(**kwargs)

        params = {'id': eiffel_notification.to_username}
        data = self.get_notify_dict_by_notification(eiffel_notification)
        result = NCHAN.publish_to_trading(params, data)
        if result and result.status_code == 200:
            this.bln_delivered = True
            DBSession.flush()

        if not success:
            return error_response(reason)
        return success_response('Sale successful.')

    @safe_headers
    @expose('json')
    def reject_calabash_campus_make_sale_notification(self, *args, **kwargs):
        LOGGER.info('reject_calabash_campus_make_sale_notification')
        LOGGER.info(str(kwargs))

        notification_id = kwargs.get('notification_id', None)
        if not notification_id:
            return error_response('No notification_id')

        notification = Notification.by_id(notification_id)
        if not notification:
            return error_response('No notification for id')

        notification.bln_actioned = True
        DBSession.flush()

        application = Application.by_attr_first('name', 'Eiffel Corp Marketplace')

        # As per JP: 30 June 2020
        from_user = REGISTRATION.get_user_profile(**{'username' : notification.from_username})
        data = from_user.get('data', {})
        from_name = data.get('name', '')
        from_surname = data.get('surname', '')

        template = MessageTemplate.by_attr_first('usage', 'Marketplace Make Sale Rejected')
        message = template.message.format(**locals())

        kwargs['application_id'] = application.id
        kwargs['notification_type_id'] = REJECTED
        kwargs['to_username'] = notification.from_username # swapping usernames so it notifies the other party
        kwargs['from_username'] = notification.to_username
        kwargs['message'] = message
        kwargs['amount'] = notification.amount
        kwargs['actioned_notification_id'] = notification.id
        this = self.create_notification(**kwargs)

        params = {'id': this.to_username}
        data = self.get_notify_dict_by_notification(this)
        result = NCHAN.publish_to_trading(params, data)
        if result and result.status_code == 200:
            this.bln_delivered = True
            DBSession.flush()
        outputdict = {
            'notification_id' : this.id,
            'notification_type' : TYPEDICT.get_pretty_name('notification_type', REJECTED),
        }
        return success_response(outputdict)

###############################################################################
# create_eiffel_corp_premium_ad_payment_notification: accept and reject
###############################################################################

    @safe_headers
    @expose('json')
    def create_eiffel_corp_premium_ad_payment_notification(self, *args, **kwargs):
        LOGGER.info('create_eiffel_corp_premium_ad_payment_notification')
        LOGGER.info(str(kwargs))

        entity_id = kwargs.get('entity_id', None)
        if not entity_id:
            return error_response('No entity_id to notify')

        wallet = Wallet.by_attr_first('entity_id', entity_id)
        if not wallet:
            return error_response('Username entity_id not found')

        amount = kwargs.get('amount', None)
        if not amount:
            return error_response('No amount to notify')

        message = kwargs.get('message', None)
        if not message:
            return error_response("No message or notify")

        application = Application.by_attr_first('name', 'Calabash Mobile')

        kwargs['to_username'] = wallet.username
        kwargs['from_username'] = wallet.username
        kwargs['application_id'] = application.id
        kwargs['notification_type_id'] = FEATURED_AD
        notification = self.create_notification(**kwargs)

        params = {'id': wallet.username}
        data = self.get_notify_dict_by_notification(notification)
        result = NCHAN.publish_to_campus(params, data)
        if result and result.status_code == 200:
            notification.bln_delivered = True
            DBSession.flush()
        outputdict = {
            'notification_id' : notification.id,
            'notification_type' : str(TYPEDICT.get_pretty_name('notification_type', FEATURED_AD)),
        }
        return success_response(outputdict)

    def create_calabash_pay_featured_ad_link(self, *args, **kwargs):
        wallet = Wallet.by_attr_first('username', 'calabash pay')
        if not wallet:
            return False

        link = WalletFeaturedAdLink()
        link.wallet_id = wallet.id
        DBSession.add(link)
        DBSession.flush()
        return link

    @safe_headers
    @expose('json')
    def accept_calabash_campus_premium_ad_payment_notification(self, *args, **kwargs):
        LOGGER.info('accept_calabash_campus_premium_ad_payment_notification')
        LOGGER.info(str(kwargs))

        notification_id = kwargs.get('notification_id', None)
        if not notification_id:
            return error_response('No notification_id')

        notification = Notification.by_id(notification_id)
        if not notification:
            return error_response('No notification for id')

        featured_ad_link = WalletFeaturedAdLink.latest_entry()
        if not featured_ad_link:
            featured_ad_link = self.create_calabash_pay_featured_ad_link()
        if not featured_ad_link:
            return error_response('No merchant linked to premium ad payments.')
        merchant_wallet = Wallet.by_id(featured_ad_link.wallet_id)

        merchant_sale_kwargs = {
            'merchant_username' : merchant_wallet.username,
            'username' : notification.from_username,
            'amount' : notification.amount,
            'reference' : notification.message,
        }
        result = self.make_merchant_sale(**merchant_sale_kwargs)
        if not result:
            return error_response(f'make_merchant_sale failed: {result}')

        # As per JP: 30 June 2020
        success = result.get('success', False)
        if success:
            template = MessageTemplate.by_attr_first('usage', 'Premium Ad Success')
            message = template.message.format(**locals())
        else:
            reason = result.get('data', '')
            template = MessageTemplate.by_attr_first('usage', 'Premium Ad Failure')
            message = template.message.format(**locals())

        notification.bln_actioned = True
        DBSession.flush()

        application = Application.by_attr_first('name', 'Eiffel Corp Marketplace')

        kwargs['application_id'] = application.id
        kwargs['notification_type_id'] = ACCEPTED
        kwargs['to_username'] = notification.to_username
        kwargs['from_username'] = notification.from_username
        kwargs['message'] = message
        kwargs['amount'] = notification.amount
        kwargs['actioned_notification_id'] = notification_id
        this = self.create_notification(**kwargs)

        params = {'id': this.to_username}
        data = self.get_notify_dict_by_notification(this)
        result = NCHAN.publish_to_trading(params, data)
        if result and result.status_code == 200:
            this.bln_delivered = True
            DBSession.flush()

        if not success:
            return error_response(reason)
        return success_response('Premium Ad Posted Successfully.')

    @safe_headers
    @expose('json')
    def reject_calabash_campus_premium_ad_payment_notification(self, *args, **kwargs):
        LOGGER.info('reject_calabash_campus_premium_ad_payment_notification')
        LOGGER.info(str(kwargs))

        notification_id = kwargs.get('notification_id', None)
        if not notification_id:
            return error_response('No notification_id')

        notification = Notification.by_id(notification_id)
        if not notification:
            return error_response('No notification for id')

        notification.bln_actioned = True
        DBSession.flush()

        application = Application.by_attr_first('name', 'Eiffel Corp Marketplace')

        # As per JP: 30 June 2020
        template = MessageTemplate.by_attr_first('usage', 'Transaction Cancelled')
        message = template.message.format(**locals())

        kwargs['application_id'] = application.id
        kwargs['notification_type_id'] = REJECTED
        kwargs['to_username'] = notification.to_username
        kwargs['from_username'] = notification.from_username
        kwargs['message'] = message
        kwargs['amount'] = notification.amount
        kwargs['actioned_notification_id'] = notification_id
        this = self.create_notification(**kwargs)

        params = {'id': this.to_username}
        data = self.get_notify_dict_by_notification(this)
        result = NCHAN.publish_to_trading(params, data)
        if result and result.status_code == 200:
            this.bln_delivered = True
            DBSession.flush()
        return success_response('Premium Ad Rejected Successfully.')

###############################################################################
# check_has_notifications: Calabash Mobile and Eiffel Corp Marketplace
###############################################################################

    @safe_headers
    @expose('json')
    def calabash_campus_check_has_notifications(self, username: str):
        LOGGER.info('calabash_campus_check_has_notifications')
        LOGGER.info(f'username: {username}')

        application = Application.by_attr_first('name', 'Calabash Mobile')
        if not application:
            return error_response('Calabash Mobile application not found')

        return self.check_has_notifications(username=username, application_id=application.id)

    @safe_headers
    @expose('json')
    def eiffel_corp_check_has_notifications(self, *args, **kwargs):
        LOGGER.info('eiffel_corp_check_has_notifications')
        LOGGER.info(f'{str(kwargs)}')
        entity_id = kwargs.get('entity_id', None)

        application = Application.by_attr_first('name', 'Eiffel Corp Marketplace')
        if not application:
            return error_response('Eiffel Corp Marketplace application not found')

        wallet = Wallet.by_attr_first('entity_id', entity_id)
        if not wallet:
            return error_response('Username entity_id not found')

        if wallet.bln_suspended:
            return error_response('Wallet is suspended.')

        return self.check_has_notifications(username=wallet.username, application_id=application.id)

    def check_has_notifications(self, username: str, application_id: int):
        notification_count = DBSession.query(Notification). \
                filter(Notification.active==True). \
                filter(Notification.bln_deleted==False). \
                filter(Notification.bln_actioned==False). \
                filter(Notification.to_username==username). \
                filter(Notification.application_id==application_id). \
                count()

        if notification_count > 0:
            return success_response(str(notification_count))
        return error_response('0')

###############################################################################
# get_notifications_list: Calabash Mobile and Eiffel Corp Marketplace
###############################################################################

    @safe_headers
    @expose('json')
    def get_calabash_campus_notifications_list(self, username: str):
        LOGGER.info('get_calabash_campus_notifications_list')
        LOGGER.info(f'username: {username}')

        application = Application.by_attr_first('name', 'Calabash Mobile')
        if not application:
            return error_response('Calabash Mobile application not found')

        return self.get_notifications_list(username=username, application_id=application.id)

    @safe_headers
    @expose('json')
    def get_eiffel_corp_notifications_list(self, entity_id: int):
        LOGGER.info('get_eiffel_corp_notifications_list')
        LOGGER.info(f'entity_id: {entity_id}')

        application = Application.by_attr_first('name', 'Eiffel Corp Marketplace')
        if not application:
            return error_response('Eiffel Corp Marketplace application not found')

        wallet = Wallet.by_attr_first('entity_id', entity_id)
        if not wallet:
            return error_response('Username entity_id not found')

        if wallet.bln_suspended:
            return error_response('Wallet is suspended.')

        return self.get_notifications_list(username=wallet.username, application_id=application.id)

    def get_notifications_list(self, username: str, application_id: int):
        dbase_query = DBSession.query(Notification). \
                filter(Notification.to_username == username). \
                filter(Notification.application_id == application_id). \
                filter(Notification.bln_deleted == False). \
                filter(Notification.bln_actioned == False). \
                filter(Notification.active == True). \
                order_by(Notification.added.desc()). \
                all()

        seenlist, unseenlist = [], []
        for item in dbase_query:
            item_dict = self.get_notify_dict_by_notification(item)

            if not item.bln_viewed:
                item.bln_viewed = True
                item.bln_delivered = True
                DBSession.flush()
                unseenlist.append(item_dict)
            else:
                seenlist.append(item_dict)

        #seenlist = sort_dict_list(seenlist, 'added')
        #unseenlist = sort_dict_list(unseenlist, 'added')
        return json.dumps({'success': True, 'seen': seenlist, 'unseen': unseenlist})

    def get_featured_actions_list(self, notification_id=None):
        if not notification_id:
            return []
        outputlist = [
            {'button_text' : 'Accept',
             'callback_url' : f'/notification/accept_calabash_campus_premium_ad_payment_notification?notification_id={notification_id}', },
            {'button_text' : 'Reject',
             'callback_url' : f'/notification/reject_calabash_campus_premium_ad_payment_notification?notification_id={notification_id}', },
        ]
        return outputlist

    def get_make_sale_actions_list(self, notification_id=None):
        if not notification_id:
            return []
        outputlist = [
            {'button_text' : 'Accept',
             'callback_url' : f'/notification/accept_calabash_campus_make_sale_notification?notification_id={notification_id}', },
            {'button_text' : 'Reject',
             'callback_url' : f'/notification/reject_calabash_campus_make_sale_notification?notification_id={notification_id}', },
        ]
        return outputlist

    def get_group_invite_actions_list(self, notification_id=None):
        if not notification_id:
            return []
        outputlist = [
            {'button_text' : 'Accept',
             'callback_url' : f'/groups/accept_group_invite_notification?notification_id={notification_id}', },
            {'button_text' : 'Reject',
             'callback_url' : f'/groups/reject_group_invite_notification?notification_id={notification_id}', },
        ]
        return outputlist

    @safe_headers
    @expose('json')
    def delete_notification(self, *args, **kwargs):
        notification_id = kwargs.get('notification_id', None)
        if not notification_id:
            return error_response('No notification_id supplied.')

        notification = Notification.by_id(notification_id)
        if not notification:
            return error_response('No notification for id.')

        notification.active = False
        DBSession.flush()
        return success_response('True')

###############################################################################
# GENERIC HELPERS
###############################################################################

    def safe_message(self, message='', *args, **kwargs):
        message = message.strip()
        message = message.replace('\r\n', '')
        message = message.replace('\r', '')
        message = message.replace('\n', '')
        return message

    def create_notification(self, *args, **kwargs):
        to_username = kwargs.get('to_username', None)
        from_username = kwargs.get('from_username', None)
        to_wallet = DBSession.query(Wallet).filter_by(username=to_username).first()
        from_wallet = DBSession.query(Wallet).filter_by(username=from_username).first()
        if not to_wallet or not from_wallet:
            return False

        message = kwargs.get('message', None)
        message = self.safe_message(message)

        this = Notification()
        this.amount = kwargs.get('amount', 0)
        this.message = message
        this.groupname = kwargs.get('groupname', None)
        this.to_username = to_username
        this.to_entity_id = to_wallet.entity_id
        this.from_username = from_username
        this.from_entity_id = from_wallet.entity_id
        this.application_id = kwargs.get('application_id', None)
        this.notification_type_id = kwargs.get('notification_type_id', None)
        this.actioned_notification_id = kwargs.get('actioned_notification_id', None)
        DBSession.add(this)
        DBSession.flush()
        return this

    def get_wallet_by_entity_id(self, entity_id=None, *args, **kwargs):
        if not entity_id:
            return False
        wallet = Wallet.by_attr_first('entity_id', entity_id)
        if not wallet:
            return False
        if wallet.bln_suspended:
            return False
        return wallet

    def get_notify_dict_by_notification(self, notification=None):
        outputdict = {}
        if not notification:
            return outputdict

        actionlist = []
        if not notification.bln_actioned:

            if notification.notification_type_id == FEATURED_AD:
                actionlist = self.get_featured_actions_list(notification.id)

            if notification.notification_type_id == MAKE_SALE:
                actionlist = self.get_make_sale_actions_list(notification.id)

            if notification.notification_type_id == GROUP_INVITE:
                actionlist = self.get_group_invite_actions_list(notification.id)

        outputdict['notification_id'] = notification.id
        outputdict['amount'] = int(notification.amount)
        outputdict['message'] = notification.message
        outputdict['added'] = notification.added.strftime('%d/%m/%Y %H:%M:%S')
        outputdict['actioned_notification_id'] = notification.actioned_notification_id
        outputdict['actions'] = actionlist
        return outputdict

    def send_group_invite_notification(self, *args, **kwargs):
        username = kwargs.get('username', None)
        groupname = kwargs.get('groupname', None)

        # groupname is actually group_id
        group = UserGroup.by_id(groupname)
        if group:
            groupname = group.groupname

        to_username = kwargs.get('to_username', None)
        application = Application.by_attr_first('name', 'Calabash Mobile')
        template = MessageTemplate.by_attr_first('usage', 'Group Invite')
        message = template.message.format(**locals())

        kwargs['message'] = message
        kwargs['application_id'] = application.id
        kwargs['to_username'] = to_username
        kwargs['from_username'] = username
        kwargs['notification_type_id'] = GROUP_INVITE
        notification = self.create_notification(**kwargs)
        if not notification:
            return None, None

        params = {'id': to_username}
        data = self.get_notify_dict_by_notification(notification)
        result = NCHAN.publish_to_campus(params, data)
        if result and result.status_code == 200:
            notification.bln_delivered = True
            DBSession.flush()

        try:
            notification_type = TYPEDICT.get_pretty_name('notification_type', GROUP_INVITE)
        except TypeError:
            notification_type = 'Group Invite'
        return notification.id, notification_type

    def send_refund_success_notification(self, *args, **kwargs):
        to_username = kwargs.get('toUsername', None)
        from_username = kwargs.get('fromUsername', None)
        application = Application.by_attr_first('name', 'Calabash Mobile')

        merchant_profile = REGISTRATION.get_user_profile(**{'username' : from_username})
        if not merchant_profile:
            return False

        success = merchant_profile.get('success', False)
        if not success:
            return False

        merchant_data = merchant_profile.get('data', {})
        if not merchant_data:
            return False

        merchant_name = merchant_data.get('name', None)
        merchant_surname = merchant_data.get('surname', None)
        merchant_name = f'{merchant_name} {merchant_surname}'

        try:
            amount_in_cents = int(kwargs.get('amount', 0))
        except:
            amount_in_cents = int(float(kwargs.get('amount', 0)))

        amount_in_rands = get_currency_by_locale(amount_in_cents)
        #amount_in_rands = amount_in_cents / 100
        #amount_in_rands = "{:.2f}".format(amount_in_rands)

        reference = kwargs.get('reference', None)
        template = MessageTemplate.by_attr_first('usage', 'Refund Success')
        message = template.message.format(**locals())

        kwargs['message'] = message
        kwargs['application_id'] = application.id
        kwargs['to_username'] = to_username
        kwargs['from_username'] = from_username
        kwargs['notification_type_id'] = ACCEPTED
        notification = self.create_notification(**kwargs)

        params = {'id': to_username}
        data = self.get_notify_dict_by_notification(notification)
        result = NCHAN.publish_to_campus(params, data)
        if result and result.status_code == 200:
            notification.bln_delivered = True
            DBSession.flush()
        return True

    def send_sale_success_email(self, *args, **kwargs):
        kwargs['passthrough'] = True
        result = REGISTRATION.get_user_profile(**kwargs)

        email_list = []
        data = result.get('data', {})
        if isinstance(data, str):
            return False

        contact_list = data.get('contact_list', [])

        for item in contact_list:
            contacttype = item.get('contacttype', {})
            contactname = contacttype.get('name', None)
            contactname = contactname.lower()
            contactname = str(contactname)

            if str(contactname) == 'email':
                email = item.get('value', None)
                email_list.append(email)

        if not email_list:
            return False

        amount = kwargs.get('amount', None)
        amount = get_currency_by_locale(amount)
        str_datetime = datetime.now().strftime('%a %d %b %Y %H:%M:%S')
        merchant_fullname = kwargs.get('merchant_fullname', None)
        reference = kwargs.get('reference', None)

        plain_template = MessageTemplate.by_attr_first('usage', 'Sale Success Email Plain')
        plain_text = plain_template.message.format(**locals())

        rich_template = MessageTemplate.by_attr_first('usage', 'Sale Success Email Rich')
        rich_text = rich_template.message.format(**locals())

        for email in email_list:
            e = CalabashCampusEmailCreator()
            e.add_subject('Sale | CALABASH CAMPUS')
            e.add_to_address(email)
            e.add_plain_text(plain_text)
            e.add_rich_text(rich_text)
            e.send(False)
        return True

    def send_sale_success_notification(self, *args, **kwargs):
        to_username = kwargs.get('username', None)
        from_username = kwargs.get('merchant_username', None)
        application = Application.by_attr_first('name', 'Calabash Mobile')

        merchant_profile = REGISTRATION.get_user_profile(**{'username' : from_username})
        merchant_data = merchant_profile.get('data', {})
        merchant_name = merchant_data.get('name', None)
        merchant_surname = merchant_data.get('surname', None)
        to_fullname = f'{merchant_name} {merchant_surname}'

        amount_in_cents = int(kwargs.get('amount', 0))
        amount_in_rands = get_currency_by_locale(amount_in_cents)

        reference = kwargs.get('reference', None)
        template = MessageTemplate.by_attr_first('usage', 'Sale Success')
        message = template.message.format(**locals())

        kwargs['message'] = message
        kwargs['application_id'] = application.id
        kwargs['to_username'] = to_username
        kwargs['from_username'] = from_username
        kwargs['notification_type_id'] = ACCEPTED
        notification = self.create_notification(**kwargs)

        params = {'id': to_username}
        data = self.get_notify_dict_by_notification(notification)
        result = NCHAN.publish_to_campus(params, data)
        if result and result.status_code == 200:
            notification.bln_delivered = True
            DBSession.flush()
        return merchant_name

    def send_transfer_success_email(self, *args, **kwargs):
        kwargs['passthrough'] = True
        kwargs['username'] = kwargs.get('from_username', None)
        result = REGISTRATION.get_user_profile(**kwargs)
        success = result.get('success', False)
        if not success:
            return False

        email_list = []
        data = result.get('data', {})
        if isinstance(data, str):
            return False

        contact_list = data.get('contact_list', [])
        for item in contact_list:
            contacttype = item.get('contacttype', {})
            contactname = contacttype.get('name', None)
            contactname = contactname.lower()
            contactname = str(contactname)

            if str(contactname) == 'email':
                email = item.get('value', None)
                email_list.append(email)

        if not email_list:
            return False

        amount = kwargs.get('amount', None)
        amount = get_currency_by_locale(amount)
        str_datetime = datetime.now().strftime('%a %d %b %Y %H:%M:%S')
        to_fullname = kwargs.get('to_fullname', None)
        reference = kwargs.get('reference', None)

        plain_template = MessageTemplate.by_attr_first('usage', 'Transfer Success Email Plain')
        plain_text = plain_template.message.format(**locals())

        rich_template = MessageTemplate.by_attr_first('usage', 'Transfer Success Email Rich')
        rich_text = rich_template.message.format(**locals())

        for email in email_list:
            e = CalabashCampusEmailCreator()
            e.add_subject('Transfer | CALABASH CAMPUS')
            e.add_to_address(email)
            e.add_plain_text(plain_text)
            e.add_rich_text(rich_text)
            e.send(False)
        return True

    def send_transfer_success_notification(self, *args, **kwargs):
        to_username = kwargs.get('to_username', None)
        from_username = kwargs.get('from_username', None)
        application = Application.by_attr_first('name', 'Calabash Mobile')

        to_profile = REGISTRATION.get_user_profile(**{'username' : to_username})
        to_data = to_profile.get('data', {})
        if isinstance(to_data, str):
            return False

        to_name = to_data.get('name', None)
        to_surname = to_data.get('surname', None)
        to_fullname = f'{to_name} {to_surname}'

        amount = kwargs.get('amount', 0)
        try:
            amount_in_cents = int(amount)
        except:
            amount_in_cents = None
        if not amount_in_cents:
            return False

        amount_in_rands = get_currency_by_locale(amount_in_cents)

        reference = kwargs.get('reference', None)
        template = MessageTemplate.by_attr_first('usage', 'Transfer Success')
        message = template.message.format(**locals())

        kwargs['message'] = message
        kwargs['application_id'] = application.id
        kwargs['to_username'] = from_username # Swapped deliberately, the from_username must get the notification back
        kwargs['from_username'] = to_username # Swapped deliberately, the to_username must send the notification
        kwargs['notification_type_id'] = ACCEPTED
        notification = self.create_notification(**kwargs)

        params = {'id': from_username}
        data = self.get_notify_dict_by_notification(notification)
        result = NCHAN.publish_to_campus(params, data)
        if result and result.status_code == 200:
            notification.bln_delivered = True
            DBSession.flush()
        return to_fullname

###############################################################################
# QR CODES
###############################################################################

    @safe_headers
    @expose('json')
    def get_qrcode_url_with_amount(self, *args, **kwargs):
        amount_in_cents = kwargs.get('amount_in_cents', None)
        if not amount_in_cents:
            return error_response('Unable to get amount_in_cents')
        try:
            amount_in_cents = int(amount_in_cents)
        except:
            return error_response('Unable to int amount_in_cents')

        amount_in_rands = amount_in_cents / 100
        amount_in_rands = "{:.2f}".format(amount_in_rands)
        kwargs['amount_in_rands'] = amount_in_rands
        return self.get_qrcode_url(**kwargs)

    @safe_headers
    @expose('json')
    def get_qrcode_url_without_amount(self, *args, **kwargs):
        kwargs['amount_in_rands'] = 0.00
        return self.get_qrcode_url(**kwargs)

    @safe_headers
    @expose('json')
    def get_qrcode_url_static(self, *args, **kwargs):
        token = self.get_token_from_balance(**kwargs)
        if not token:
            return error_response('Unable to get token')

        reference = None
        result = REGISTRATION.get_user_profile(**kwargs)
        success = result.get('success', False)
        if success:
            data = result.get('data', {})
            reference = data.get('REF', None)
            if not reference:
                reference = result.get('reference_number', None)
        if not reference:
            return error_response('Unable to get reference')

        kwargs['token'] = token
        kwargs['reference'] = reference
        url = NETCASH.static_qr(**kwargs)
        return success_response(url)

    def get_qrcode_url(self, *args, **kwargs):
        token = self.get_token_from_balance(**kwargs)
        if not token:
            return error_response('Unable to get token')

        reference = None
        result = REGISTRATION.get_user_profile(**kwargs)
        success = result.get('success', False)
        if success:
            data = result.get('data', {})
            reference = data.get('REF', None)
            if not reference:
                reference = result.get('reference_number', None)
        if not reference:
            return error_response('Unable to get reference')

        kwargs['token'] = token
        kwargs['reference'] = reference
        url = NETCASH.dynamic_qr_with_variable_amount(**kwargs)
        return success_response(url)

    @safe_headers
    @expose('json')
    def unlink_loyalty_program(self, *args, **kwargs):

        loyalty = MerchantLoyaltyProgram.latest_entry()
        kwargs['loyalty_program'] = loyalty.name

        result = MYIMALI.unlink_loyalty_program(**kwargs)
        return success_response()

    @safe_headers
    @expose('json')
    def get_transaction_by_id(self, *args, **kwargs):
        LOGGER.info('get_transaction_by_id')
        LOGGER.info(str(kwargs))

        transaction_id = kwargs.get('transaction_id', None)
        if not transaction_id:
            return error_response('No transaction_id supplied.')

        transaction = TransactionHistory.by_id(transaction_id)
        if not transaction:
            return error_response('No transaction for transaction_id.')

        return success_response(transaction)

    @safe_headers
    @expose('json')
    def get_payment_wicode(self, *args, **kwargs):
        LOGGER.info('get_payment_wicode')
        LOGGER.info(str(kwargs))
        username = kwargs.get('username', None)

        kwargs['transaction_type'] = 'payment'
        result = MYIMALI.generate_wicode(**kwargs)
        success = result.get('success', False)

        if not success:
            error = result.get('error', '')
            transfer_result = COMMON.auto_transfer_user_api_key(error, username)
            if transfer_result:
                return self.get_payment_wicode(**kwargs)
            return error_response(error)

        return success_response(result)

    @safe_headers
    @expose('json')
    def get_withdrawal_wicode(self, *args, **kwargs):
        LOGGER.info('get_withdrawal_wicode')
        LOGGER.info(str(kwargs))

        amount = kwargs.get('amount', None)
        username = kwargs.get('username', None)

        ERROR_OUTPUTDICT = {
                'date' : datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'transaction_cost' : '',
                'amount' : amount,
                'wiCode' : '',
                'retailerId' : 'null',
                'transactionId' : '',
                'apiUsername' : '',
                'result' : '',
                'transactionType' : '',
                'totalAmount' : '',
                'ref' : '',
                'queueName' : '',
                'month' : '',
                'success' : False,
                'couponType' : '',
                'expireDate' : '',
                'userType' : '',
                'day' : '',
                'username' : username,
                'status' : '',
                'error' : '',
        }


        kwargs['transaction_type'] = 'withdrawal'
        result = MYIMALI.generate_wicode(**kwargs)
        success = result.get('success', False)

        if not success:
            error = result.get('error', '')
            transfer_result = COMMON.auto_transfer_user_api_key(error, username)
            if transfer_result:
                return self.get_withdrawal_wicode(**kwargs)

            ERROR_OUTPUTDICT['error'] = error
            return error_response(ERROR_OUTPUTDICT)

        return success_response(result)

    @safe_headers
    @expose('json')
    def expire_payment_wicode(self, *args, **kwargs):
        LOGGER.info('expire_payment_wicode')
        LOGGER.info(str(kwargs))
        username = kwargs.get('username', None)

        kwargs['method'] = 'payment'
        result = MYIMALI.expire_wicode(**kwargs)
        success = result.get('success', False)

        if not success:
            error = result.get('error', '')
            transfer_result = COMMON.auto_transfer_user_api_key(error, username)
            if transfer_result:
                return self.expire_payment_wicode(**kwargs)
            return error_response(error)

        return success_response(result)

    @safe_headers
    @expose('json')
    def expire_withdrawal_wicode(self, *args, **kwargs):
        LOGGER.info('expire_withdrawal_wicode')
        LOGGER.info(str(kwargs))
        username = kwargs.get('username', None)

        kwargs['method'] = 'withdrawal'
        result = MYIMALI.expire_wicode(**kwargs)
        success = result.get('success', False)

        if not success:
            error = result.get('error', '')
            transfer_result = COMMON.auto_transfer_user_api_key(error, username)
            if transfer_result:
                return self.expire_withdrawal_wicode(**kwargs)
            return error_response(error)

        return success_response(result)

    @safe_headers
    @expose('json')
    def get_user_wicodes(self, *args, **kwargs):
        LOGGER.info('get_user_wicodes')
        LOGGER.info(str(kwargs))
        username = kwargs.get('username', None)

        result = MYIMALI.get_user_wicodes(**kwargs)
        success = result.get('success', False)

        if not success:
            error = result.get('error', '')
            transfer_result = COMMON.auto_transfer_user_api_key(error, username)
            if transfer_result:
                return self.get_user_wicodes(**kwargs)
            return error_response(error)

        wicode_list = result.get('wicodes', [])
        return success_response(wicode_list)
