#!/bin/python
# -*- coding: utf-8 -*-

import os
import pandas as pd
from datetime import datetime

from tg import request

from rocket.lib.tg_utils import remove_hash_from_filename, str_to_date
from rocket.lib.type_utils import TypeDictionary

from rocket.model import *
from rocket.model.sql_entity import Entity, EntityPerson
from rocket.model.sql_batch_import import MemberRequest, BatchImport, BatchImportAudit, BatchImportError
from rocket.lib.batch_import import ImportHandler

TYPEUTIL = TypeDictionary()

class MemberImport(ImportHandler):

    def __repr__(self):
        return f'<MemberImport: filename={self.filename}>'

    def __init__(self, *args, **kwargs):
        super(MemberImport, self).__init__(**kwargs)
        self.entity_person_mobile_type_id = TYPEUTIL.get_id_of_name('entity_person_identity_type', 'mobile')
        self.entity_person_identity_type_id = TYPEUTIL.get_id_of_name('entity_person_identity_type', 'identity_number')

    def start_import(self, *args, **kwargs):
        start = datetime.now()
        self.new_batch_import_audit(f'Member import starting for {self.sane_filename}')

        print('Starting Parse:')
        parse_result = self.run_parse()
        print('Completed Parse:', parse_result)
        if not parse_result:
            return False

        print('Starting Import:')
        import_result = self.run_import()
        print('Completed Import:', import_result)
        if not import_result:
            return False

        print('Starting Complete:')
        complete_result = self.run_complete()
        print('Completed Complete:', complete_result)
        if not complete_result:
            return False

        end = datetime.now()
        self.new_batch_import_audit(f'Member import finished for {self.sane_filename} it took {end-start} seconds.')
        return True

    def run_parse(self, *args, **kwargs):
        start = datetime.now()
        self.new_batch_import_audit(f'Parse starting for {self.sane_filename}')

        # if not self.product_owner_id:
        #     self.new_batch_import_audit(f'No Product Owner selected for {self.sane_filename}')
        #     self.run_parse_fail()
        #     return False

        rejected_count = 0
        accepted_count = 0

        fileobject = self.get_file_from_pandas(usecols=[
                "IDNumber",
                "Title",
                "Name",
                "Surname",
                "MobileNumber",
                "IntermediaryCode",
                "Gender",
                "DOB",
                "Language",
                "StartingDate",
                "ClientCode",
                "ClientReference",
                ])

        if fileobject.empty:
            self.new_batch_import_audit(f'No Records returned from Pandas {self.sane_filename}')
            self.run_parse_fail()
            return False

        for i, row in fileobject.iterrows():
            identity_number = row.get('IDNumber', None)

            if not self.check_mandatory_member_fields(row):
                rejected_count += 1
                self.new_batch_import_error(f'Missing member information for row {i+1} ID Number {identity_number}')
                continue

            if not self.check_optional_beneficiary_fields(row):
                rejected_count += 1
                self.new_batch_import_error(f'Missing beneficiary information for row {i+1} ID Number {identity_number}')
                continue

            exists = self.get_member_request_for_id_number(identity_number)
            if exists:
                #rejected_count += 1
                self.new_batch_import_error(f'Duplicate member request for identity number {identity_number} - row {i+1}')
                continue

            result = self.save_member_request(row)


        end = datetime.now()
        self.new_batch_import_audit(f'Parse finished for {self.sane_filename} it took {end-start} seconds.')
        self.update_batch_import(**{
            'notes': '=>Parse',
            'total_count': fileobject.shape[0],
            'rejected_count': rejected_count,
            })
        print('RETURNING: ')
        return True

    def run_parse_fail(self, *args, **kwargs):
        start = datetime.now()
        end = datetime.now()
        self.new_batch_import_audit(f'Parse finished for {self.sane_filename} it took {end-start} seconds.')
        self.update_batch_import(**{
            'notes': '=>Parse ERROR',
            })
        return

    def run_import(self, *args, **kwargs):
        start = datetime.now()
        self.new_batch_import_audit(f'Import starting for {self.sane_filename}')

        rejected_count = self.batch_import.rejected_count
        accepted_count = self.batch_import.accepted_count

        unknown_gender_id = TYPEUTIL.get_id_of_name('entity_person_gender_type', 'unknown')
        if not unknown_gender_id:
            return False

        unknown_title_id = self.unknown_person_title_id

        requestlist = MemberRequest.by_attr_all('batch_import_id', self.batch_import_id)
        if not requestlist:
            # There are no reques records to import
            self.new_batch_import_audit(f'No request records found to import!')
            self.new_batch_import_audit(f'Import ending for {self.sane_filename}. Duration: {datetime.now() - start}')

            self.update_batch_import(**{
                'notes': '=>Import',
                'rejected_count': rejected_count,
                'accepted_count': accepted_count,
                'is_complete_load': True,
                'is_successful': True,
                })
            return

        for req in requestlist:
            # Make sure the member does not already exist.
            exists = self.member_exists_for_id_number(req.identity_number)
            if exists:
                rejected_count += 1
                self.new_batch_import_error(f'Member already exists for identity number {req.identity_number}')
                DBSession.delete(req)
                continue

            accepted_count += 1
            if not req.gender:
                req.gender = 'Unknown'

            entity_person_gender_type_id = TYPEUTIL.get_id_of_name('entity_person_gender_type', req.gender.lower())
            if not entity_person_gender_type_id:
                entity_person_gender_type_id = unknown_gender_id

            # date_of_birth = req.date_of_birth.isoformat()
            date_of_birth = req.date_of_birth.strftime("%m-%d-%Y")

            dict_person = {
                'entity_person_title_id': unknown_title_id,
                'name': req.first_name,
                'surname': req.surname,
                'preferred_name': req.first_name,
                'entity_person_gender_type_id': entity_person_gender_type_id,
                'date_of_birth': date_of_birth,
                'language_id': self.default_language_id,
                'identity_type_id': self.entity_person_identity_type_id,
                'number': req.identity_number,
                'mobile': req.mobile_number,
            }
            print()
            print('Creating Member: ', dict_person)
            entity_id = self.save_new_person(**dict_person)
            if not entity_id:
                rejected_count += 1
                accepted_count -= 1
                self.new_batch_import_error(f'Unable to create Member for identity number {req.identity_number}')
            DBSession.delete(req)

        end = datetime.now()
        self.new_batch_import_audit(f'Import finished for {self.sane_filename} it took {end-start} seconds.')
        self.update_batch_import(**{
            'notes': '=>Import',
            'rejected_count': rejected_count,
            'accepted_count': accepted_count,
            'is_complete_load': True,
            'is_successful': True,
            })
        return True

    def run_complete(self, *args, **kwargs):
        start = datetime.now()
        self.new_batch_import_audit(f'Complete starting for {self.sane_filename}')

        requestlist = MemberRequest.by_attr_all('batch_import_id', self.batch_import_id)
        if requestlist:
            len_requestlist = len([x for x in requestlist])
            self.new_batch_import_error(f'{len_requestlist} MemberRequests still exist for {self.sane_filename}')

        end = datetime.now()
        self.new_batch_import_audit(f'Complete finished for {self.sane_filename} it took {end-start} seconds.')
        self.update_batch_import(**{
            'notes': '=>Complete',
            })
        return True

    def check_mandatory_member_fields(self, row):
        # Is this necessary for Omvim??
        identity_number = row.get('IDNumber', None)
        name = row.get('Name', None)

        surname = row.get('Surname', None)
        mobile = row.get('MobileNumber', None)
        return all([name, surname, mobile, identity_number])

    def check_optional_beneficiary_fields(self, row):
        return True

        title = row.get('Title', None)
        inter_code = row.get('IntermediaryCode', None)
        gender = row.get('Gender', None)
        dob = row.get('DOB', None)
        language = row.get('Language', None)
        start_date = row.get('StartingDate', None)
        client_code = row.get('ClientCode', None)
        client_ref = row.get('ClientReference', None)

        # Is this necessary for Omvim??
        # non_list = [title, inter_code, gender, dob, language, start_date, client_code, client_ref ]
        # if not any(non_list): return True
        # if any(non_list) and all(non_list):
        #     return True
        # return False

    def get_member_request_for_id_number(self, identity_number=None, *args, **kwargs):
        if not identity_number:
            return None

        return DBSession.query(MemberRequest).\
            filter(MemberRequest.batch_import_id == self.batch_import_id).\
            filter(MemberRequest.identity_number == identity_number).\
            first()

    def member_exists_for_id_number(self, mobile_number=None, *args, **kwargs):
        if not mobile_number:
            return None

        return DBSession.query(EntityPersonIdentity).\
            filter(EntityPersonIdentity.entity_person_identity_type_id == self.entity_person_mobile_type_id).\
            filter(EntityPersonIdentity.value == mobile_number ).\
            first()

    def save_member_request(self, row, *args, **kwargs):
        identity_number = row.get('IDNumber', '')
        first_name = row.get('Name', '')
        surname = row.get('Surname', '')
        preferred_name = row.get('PreferredName', '')
        mobile_number = row.get('MobileNumber', '')
        intermediary_code = row.get('IntermediaryCode', '')
        gender = row.get('Gender', None)
        if not gender:
            gender = "Unknown"
        gender_type_id = TYPEUTIL.get_id_of_name('entity_person_gender_type', gender.lower())
        if not gender_type_id:
            gender_type_id = TYPEUTIL.get_id_of_name('entity_person_gender_type', 'unknown')

        date_of_birth = row.get('DOB', self.null_date)
        if not date_of_birth:
            date_of_birth = self.null_date
        else:
            date_of_birth = date_of_birth.date()

        language = row.get('Language', 'English')
        language_type_id = self.get_language_id_by_name(language)
        startdate = row.get('StartingDate', self.null_date)
        client_code = row.get('ClientCode', '')
        client_id = self.get_client_id_by_code(client_code)
        client_reference = row.get('GroupReference', '')

        this = MemberRequest()
        this.batch_import_id = self.batch_import_id
        this.identity_number = identity_number
        this.first_name = first_name
        this.surname = surname
        this.preferred_name = preferred_name
        this.mobile_number = mobile_number
        this.intermediary_code = intermediary_code
        this.gender = gender
        this.gender_type_id = gender_type_id
        this.date_of_birth = date_of_birth
        this.language = language
        this.language_type_id = language_type_id
        this.startdate = startdate
        this.client_code = client_code
        this.client_id = client_id
        this.client_reference = client_reference
        this.added_by = self.user_id
        DBSession.add(this)
        DBSession.flush()

        return this.id

class MemberImportRecovery(MemberImport):

    def __repr__(self):
        return f'<MemberImportRecovery: filename={self.filename}>'

    def __init__(self, *args, **kwargs):
        super(MemberImportRecovery, self).__init__(**kwargs)

    def restart_import(self, *args, **kwargs):
        start = datetime.now()
        self.new_batch_import_audit(f'Member import restarting for {self.sane_filename}')

        print('ReStarting Import:')
        import_result = self.run_import()
        print('Completed Import:', import_result)
        if not import_result:
            return False

        print('Starting Complete:')
        complete_result = self.run_complete()
        print('Completed Complete:', complete_result)
        if not complete_result:
            return False

        end = datetime.now()
        self.new_batch_import_audit(f'Member import finished for {self.sane_filename} it took {end-start} seconds.')
        return True
