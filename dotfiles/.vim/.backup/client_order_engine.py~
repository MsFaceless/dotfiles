"""Client Order Class"""
from timeit import default_timer as timer
from tg.predicates import has_permission
import urllib.parse
from tg.i18n import ugettext as _, lazy_ugettext as l_

import string
import datetime
import random
from sqlalchemy import func, desc, asc, and_, or_, cast
from tg import expose, require, redirect, validate, flash, url, request, response, predicates

from tanzanite.model import *
from tanzanite.lib.tg_utils import *
from tanzanite.lib.email_creator import EmailCreator
from tanzanite.lib.stock_soh_engine import StockSohRecalculation
from tanzanite.controllers.common import CommonController
 
COMMON = CommonController()

class ClientOrderClass():
    def __init__(self, client_id=None,  client_order_batch_id=None,  ordering_method_id=None, *args, **kwargs):
        # Defaults
        self.client_order_batch_id = client_order_batch_id
        self.client_id = client_id
        self.ordering_method_id = ordering_method_id
       
        # Defaults
        self.usernow = request.identity.get('user', {})
        self.managed_id = COMMON.get_type_id(StockManagementType, 'Managed')

        self.automatic_id = COMMON.get_type_id(OrderingMethod, 'Automatic')
        self.manual_id = COMMON.get_type_id(OrderingMethod, 'Manual')

        self.received_id = COMMON.get_type_id(ClientOrderStatus, 'Received')
        self.cancelled_id = COMMON.get_type_id(ClientOrderStatus, 'Cancelled')
        self.created_id = COMMON.get_type_id(ClientOrderStatus, 'Created')
        self.shipped_id = COMMON.get_type_id(ClientOrderStatus,'Shipped')
        self.orderd_id = COMMON.get_type_id(ClientOrderStatus,'Ordered')
        self.filled_id = COMMON.get_type_id(ClientOrderStatus,'Filled')

        self.in_process_id = COMMON.get_type_id(ClientOrderBatchStatus, 'InProcess')

        self.audit_action_id = COMMON.get_type_id(AuditAction,'Audit'),
        self.audit_type_id = COMMON.get_type_id(AuditType,'ClientOrderDetail'),

        self.in_stock_id = COMMON.get_type_id(CardStatus,'InStock')
        self.branch_card_id = COMMON.get_type_id(CardStatus,'BranchStore')

        self.cage_store_id = COMMON.get_cage_store_id()
        self.cage_store_location_id = COMMON.get_cage_store_location_id()
        self.bulk_store_id = COMMON.get_bulk_store_id()
        self.bulk_store_location_id = COMMON.get_bulk_store_location_id()
        self.outbound_store_id = COMMON.get_outbound_store_id()
        self.outbound_store_location_id = COMMON.get_outbound_store_location_id()

        if not self.ordering_method_id: 
            self.ordering_method_id = self.manual_id

        if not self.client_order_batch_id: 
            self.client_order_batch_id = self.new_client_order_batch()
        # print('self.client_order_batch_id: ', self.client_order_batch_id)
        self.client_order_batch = ClientOrderBatch.by_id(self.client_order_batch_id)

        # print('self.client_order_batch: ', self.client_order_batch)
        # print('self.client_order_batch: ', self.client_order_batch.client_id)
        # print('self.client_order_batch: ', self.client_order_batch.client_order_batch_status_id)
        # print('self.client_order_batch: ', self.client_order_batch.ordering_method_id)
        # print('self.client_order_batch: ', self.client_order_batch.created)
        # print('self.client_order_batch: ', self.client_order_batch.created_by_id)

        self.created_date = self.client_order_batch.created

        if not self.client_id:
            self.client_id = self.client_order_batch.client_id

        self.client = Client.by_id(self.client_id)

    def new_client_order_batch(self, *args, **kwargs):

        this = ClientOrderBatch()
        this.client_id = self.client_id
        this.client_order_batch_status_id = self.created_id
        this.ordering_method_id = self.ordering_method_id
        this.created = datetime.now()
        this.created_by_id = self.usernow.id
        DBSession.add(this)
        DBSession.flush()
        return this.id

    def generate_order_number(self, client_branch_id=None, *args, **kwargs):
        if not client_branch_id: return None

        client_branch = ClientBranch.by_id(client_branch_id)
        if not client_branch: return None

        store_number = client_branch.store_number
        sane_store_number = store_number.replace(' ', '')
        today = date.today()
        str_today = today.strftime("%Y%m%d")

        while True:
            str_random_number = str(random.randint(1, 99999))
            str_random_number = str_random_number.zfill(5)
            order_number = f"{sane_store_number}_{str_today}{str_random_number}"
            exists = DBSession.query(ClientOrder). \
                filter(ClientOrder.order_number == order_number). \
                first()
            if exists: continue
            break
        return order_number

    def send_mail_now(self, subject='Unknown Subject', email=None, plain_text='', rich_text=''):
        e = EmailCreator()
        e.add_subject(subject)
        e.add_to_address(email)
        e.add_plain_text(plain_text)
        e.add_rich_text(rich_text)
        e.send(verbose=False)

    def check_all_filled(self, client_order_id=None, *args, **kwargs):
        #TESTED TGJ 20200213
        result = DBSession.query(ClientOrderDetail). \
                filter(ClientOrderDetail.client_order_id == client_order_id). \
                filter(ClientOrderDetail.filled == 0). \
                value(func.count(ClientOrderDetail.id))
        return result

    def write_card_history(self, card_id=None, store_location_id=None, *args, **kwargs):
        #TESTED TGJ: 20200212
        if not card_id or not store_location_id: return

        #write the history
        this = CardHistory()
        this.card_id = card_id
        this.card_status_id = self.in_stock_id
        this.date_time = datetime.now()
        this.user_id = self.usernow.id
        this.store_location_id = store_location_id
        DBSession.add(this)
        DBSession.flush()
        return

    def add_audit_log(self, *args, **kwargs):
        audit_action_id  = kwargs.get('audit_action_id', None)
        audit_type_id = kwargs.get('audit_type_id', None)
        key = kwargs.get('key', 0)
        key_auxiliary_1 = kwargs.get('key_auxillary', 0)
        key_auxiliary_2 = kwargs.get('key_auxillary2', 0)
        message = kwargs.get('message', 'Unknown Audit')
        card_id = kwargs.get('card_id', 0)
        user_id = self.usernow.id
        
        #mandatory fields.
        if not audit_action_id \
           or not audit_type_id \
           or not user_id \
           or not message: return False

        this = Audit()
        this.audit_action_id = audit_action_id
        this.audit_type_id = audit_type_id
        this.key = key
        this.level_1_type_id = 0
        this.key_auxiliary_1 = key_auxiliary_1
        this.level_2_type_id = 0
        this.key_auxiliary_2 = key_auxiliary_2
        this.level_3_type_id = 0
        this.card_id = card_id
        this.message = message
        this.date_time = datetime.now()
        this.user_id = user_id
        DBSession.add(this)
        DBSession.flush()
    
        return True

    def write_client_order_history(self, client_order_id=None, client_order_status_id=None, *args, **kwargs):
        #TESTED TGJ: 20200212
        if not client_order_id \
           or not client_order_status_id: return False

        this = ClientOrderHistory()
        this.client_order_id = client_order_id
        this.client_order_status_id = client_order_status_id
        this.date_time = datetime.now()
        this.user_id = self.usernow.id
        DBSession.add(this)
        DBSession.flush()
        return

    def write_client_order_batch_history(self, client_order_batch_status_id=None, *args, **kwargs):
        #TESTED TGJ: 20200213
        if not self.client_order_batch_id \
           or not client_order_batch_status_id: return False
        this = ClientOrderBatchHistory()
        this.client_order_batch_id = self.client_order_batch_id
        this.client_order_batch_status_id = client_order_batch_status_id
        this.date_time = datetime.now()
        this.user_id = self.usernow.id
        DBSession.add(this)
        DBSession.flush()
        return

    def recalc_soh(self, store_location_id=None, *args, **kwargs):
        #recaclulate all SOH.
        ENGINE = StockSohRecalculation(store_location_id)
        ENGINE.start()
        return

    def update_store_level(self, product_id=None, store_id=None, *args, **kwargs):
        #TESTED TGJ 20200213
        if not product_id or not store_id: return False
        #TGJ: Refactor!!!
        total_qty = self.get_available_card(product_id, store_id)

        product_store_level = DBSession.query(ProductStoreLevel). \
                filter(ProductStoreLevel.product_id == product_id). \
                filter(ProductStoreLevel.store_id == store_id). \
                first()

        if not product_store_level:
            store_loc = DBSession.query(StoreLocation).\
                filter(StoreLocation.store_id==store_id).\
                first()
            product_store_level = ProductStoreLevel()
            product_store_level.store_location_id = store_loc.id
        product_store_level.quantity = total_qty if total_qty else 0
        product_store_level.date_time = datetime.now()
        product_store_level.product_id = product_id
        product_store_level.store_id = store_id
        product_store_level.user_id = self.usernow.id
        if not product_store_level.id:
            DBSession.add(product_store_level)
        DBSession.flush()
        return True

    def get_available_card(self, product_id=None, store_id=None, *args, **kwargs):
        if not product_id or not store_id: return 0
        store = Store.by_id(store_id)
        store_location = StoreLocation.by_store_id(store.id)
        count = DBSession.query(Card). \
            filter(Card.store_location_id == store_location.id). \
            filter(Card.product_id == product_id). \
            filter(or_((Card.card_status_id == self.in_stock_id), \
                       (Card.card_status_id == self.branch_card_id))). \
            value(func.count(Card.id))
        return count

    def card_status_location_change(self, packing_detail_list=None, store_location_id=None, card_status_id=None, product_id=None, *args, **kwargs):
        pack_mappings = []
        card_mappings = []
        card_history_mappings = []
        if not packing_detail_list  \
           or not store_location_id \
           or not card_status_id \
           or not product_id:
            return pack_mappings, card_mappings, card_history_mappings

        for item in packing_detail_list:
            pack_mappings.append({'id':item.id, 'store_location_id': store_location_id})

            inner_list = PackingDetail.all_by_outer_pack_id(item.id)
            if inner_list:
                new_pack_mappings, new_card_mappings, new_card_history_mappings = \
                  self.card_status_location_change(inner_list, store_location_id, card_status_id, product_id)

                pack_mappings.extend(new_pack_mappings)
                card_mappings.extend(new_card_mappings)
                card_history_mappings.extend(new_card_history_mappings)
            else: 
                card_list = Card.by_packing_detail_id(item.id)
                if card_list:
                    for card in card_list:
                        card_mappings.append({'id':card.id, 'store_location_id': store_location_id, 'card_status_id': card_status_id})
                        #write the history
                        card_history_mappings.append({
                            'card_id': card.id, 
                            'card_status_id': self.in_stock_id, 
                            'date_time': datetime.now(), 
                            'user_id': self.usernow.id, 
                            'store_location_id': store_location_id, 
                            })
        return pack_mappings, card_mappings, card_history_mappings

    def get_pack_list_from_client_order_detail(self, client_order_detail_id=None, *args, **kwargs):
        return DBSession.query(PackingDetail). \
            join(ClientOrderDetailPack, ClientOrderDetailPack.packing_detail_id == PackingDetail.id). \
            filter(ClientOrderDetailPack.client_order_detail_id == client_order_detail_id). \
            all()


# Things that need to be done here.
# 1   Build a new order for all branches for this client that are running low on stock.
# 2   Automatically fill an order using FIFO.
# 3   Ship this order.

#################################################################################
#
# Client Order Create.
#
#################################################################################

class ClientOrderBatchAutoCreate(ClientOrderClass):
    def __init__(self, client_id=None, client_order_batch_id=None, ordering_method_id=None, *args, **kwargs):
        super(ClientOrderBatchAutoCreate, self).__init__(client_id, client_order_batch_id, ordering_method_id)

        self.filled_id = COMMON.get_type_id(ClientOrderStatus, 'Filled')
        self.picked_id = COMMON.get_type_id(CardStatus,'Picked')
        self.in_process_id = COMMON.get_type_id(ClientOrderBatchStatus, 'InProcess')

    def process(self, *args, **kwargs):
        #Get the branches for this client that pass the filterd
        branch_list = self.get_automatic_managed_branch_list()

        if not branch_list: return json.dumps({'success': 'false', })

        for branch in branch_list:
            new_client_order_id = None
            #Chedck if I need to order for this branch
            store_location_id = self.get_store_location_id(branch.id)
            if not store_location_id: continue

            branch_product_list = self.get_branch_product_list(branch.id)
            if not branch_product_list: continue

            for branch_product in branch_product_list:

                store_level = self.has_stock_less_then_re_order_level(branch_product.product_id, store_location_id, branch_product.min_re_order)
                if not store_level: continue
                found = self.is_product_already_on_existing_order(branch.id, branch_product.product_id)
                if found: continue

                if not new_client_order_id:
                    #For each Branch
                    new_client_order_id = self.create_new_client_order(branch.id, branch.default_delivery_method_id)

                product = Product.by_id(branch_product.product_id)
                order_quantity = branch_product.standard_order

                if product.client_reorder_type_id == product.level_1_type_id:
                    order_quantity = branch_product.standard_order
                elif product.client_reorder_type_id == product.level_2_type_id:
                    order_quantity = branch_product.standard_order / product.level_2_quantity
                else: #product.client_reorder_type_id == product.level_3_type_id:
                    order_quantity = branch_product.standard_order / (product.level_2_quantity * product.level_3_quantity)

                #Create the detail here.
                self.create_client_order_detail(new_client_order_id, product.id, order_quantity, product.client_reorder_type_id)

        return json.dumps({'success': 'true', 'client_order_batch_id': self.client_order_batch_id})

    def get_automatic_managed_branch_list(self, *args, **kwargs):
        return DBSession.query(ClientBranch). \
            filter(ClientBranch.stock_management_type_id == self.managed_id). \
            filter(ClientBranch.ordering_method_id == self.automatic_id). \
            filter(ClientBranch.client_id==self.client_id). \
            filter(ClientBranch.is_active==True). \
            order_by(asc(func.lpad(ClientBranch.store_number, 10, ' '))). \
            all()

    def get_branch_product_list(self, branch_id=None, *args, **kwargs):
        return DBSession.query(ClientBranchProduct).\
            filter(ClientBranchProduct.client_branch_id==branch_id).\
            order_by(asc(ClientBranchProduct.product_id)).\
            all()

    def has_stock_less_then_re_order_level(self, product_id=None, store_location_id=None, min_re_order=0, *args, **kwargs):
        return DBSession.query(ProductStoreLevel).\
            filter(and_((ProductStoreLevel.product_id == product_id), \
                        (ProductStoreLevel.store_location_id == store_location_id))).\
            filter(ProductStoreLevel.quantity <= min_re_order). \
            first()

                # store_level = DBSession.query(ProductStoreLevel).\
                #     filter(and_((ProductStoreLevel.product_id == branch_product.product_id), \
                #                 (ProductStoreLevel.store_location_id == store_location.id))).\
                #     filter(ProductStoreLevel.quantity <= branch_product.min_re_order). \
                #     first()

    def get_store_location_id(self, branch_id=None, *args, **kwargs):
        if not branch_id: return None
        store = Store.by_branch_id(branch_id)
        store_location = StoreLocation.by_store_id(store.id)
        return store_location.id

    def is_product_already_on_existing_order(self, branch_id=None, product_id=None, *args, **kwargs):
        # return DBSession.query(ClientOrder.Id). \
        #     join(ClientOrderDetail, ClientOrderDetail.client_order_id == ClientOrder.id).\
        #     filter(ClientOrder.client_branch_id == branch_id). \
        #     filter(and_((ClientOrder.client_order_status_id != self.received_id), \
        #         (ClientOrder.client_order_status_id != self.cancelled_id))). \
        #     filter(ClientOrderDetail.product_id == product_id). \
        #     filter(ClientOrderDetail.filled == 0). \
        #     first()
        return False

    def create_new_client_order(self, branch_id=None, delivery_method_id=None, *args, **kwargs):

        this = ClientOrder()
        this.order_number = self.generate_order_number(branch_id)
        this.shipping_box_count = 1
        # this.courier_reference = ''
        this.client_order_batch_id = self.client_order_batch_id 
        this.client_branch_id = branch_id
        this.client_order_status_id = self.created_id
        this.delivery_method_id = delivery_method_id
        this.created = self.created_date
        this.created_by_id = self.usernow.id
        DBSession.add(this)
        DBSession.flush()
        return this.id

    def create_client_order_detail(self, client_order_id, product_id, order_quantity, client_reorder_type_id, *args, **kwargs):
        this = ClientOrderDetail()
        this.client_order_id = client_order_id
        this.product_id = product_id
        this.order_quantity = order_quantity
        this.filled_quantity = 0 # Else rest falls over.
        this.reorder_type_id = client_reorder_type_id
        this.ordered = self.created_date
        this.ordered_by = self.usernow.id
        DBSession.add(this)
        DBSession.flush()
        return


#################################################################################
#
# Client Order Create.
#
#################################################################################

class ClientOrderBatchAutoProcess(ClientOrderClass):
    def __init__(self, client_id=None, client_order_batch_id=None, *args, **kwargs):
        super(ClientOrderBatchAutoProcess, self).__init__(client_id, client_order_batch_id, None)

        self.in_stock_id = COMMON.get_type_id(CardStatus,'InStock')
        self.branch_card_id = COMMON.get_type_id(CardStatus,'BranchStore')
        self.picked_id = COMMON.get_type_id(CardStatus,'Picked')


    def process(self, *args, **kwargs):
        #Automatically processes the order henerated as a result of a daily sales file import.
        if not self.client_order_batch_id:
            adminrole = Role.by_name('Administrator')
            for admin in adminrole.users:
                if not admin.email: continue
                self.send_mail_now('Tanzanite - Automatic Client Branch Order Creation Notification', 
                    admin.email, 
                    f""" Hi {admin.name},

                    There were no Client Branches with low stock levels that require an automated order to be created.

                    Kind regards,
                    The Tanzanite Team """, 
                    f""" <html><div><p>
                    Hi {admin.name}, <p> </p><p> </p>
                    <p> There were no Client Branches with low stock levels that require an automated order to be created. </p>
                    <p> </p> <p> </p> <p>
                    Kind regards,
                    </p> <p> </p> <p>
                    The Tanzanite Team
                    </p> 
                    </div> </html> """
                    )
            return False
        
        enough_stock = self.enough_stock_in_cage()
        # print('PROCESS Enough Stock: ', enough_stock)
        if not enough_stock:
            adminrole = Role.by_name('Administrator')
            for admin in adminrole.users:
                if not admin.email: continue
                self.send_mail_now('Tanzanite - Automatic Client Branch Order Creation Notification', 
                    admin.email, 
                    f""" Hi {admin.name},

                    An automated order batch has been created, but the system was
                    unable to automatically process this batch as a result of
                    insufficient cage stock.
                    Please review and complete as needed.

                    Kind regards,
                    The Tanzanite Team""", 
                    f""" <html><div><p>
                    Hi {admin.name}, <p> </p><p> </p>
                    <p> An automated order batch has been created, but the system was 
                    unable to automatically process this batch as a result of
                    insufficient cage stock. </p> 
                    <p> Please review and complete as needed.</p>
                    <p> </p> <p> </p> <p>
                    Kind regards,
                    </p> <p> </p> <p>
                    The Tanzanite Team
                    </p> 
                    </div> </html> """
                    )
            return False

        #Process the order.
        #Look only for unfilled orders.
        client_order_list = self.get_client_order_list_to_process()

        if not client_order_list: return False

        start = timer()
        print('Starting Loop: ')
        loopcnt = 0

        for order in client_order_list:
            loopcnt += 1
            # Only unfilled items.
            order_detail_list = DBSession.query(ClientOrderDetail).\
                filter(ClientOrderDetail.client_order_id == order.id).\
                filter(ClientOrderDetail.filled_quantity <= 0).\
                all()

            for item in order_detail_list:
                item.filled_quantity = item.order_quantity
                item.filled = datetime.now()
                item.filled_by_id = self.usernow.id
                # DBSession.flush()
                #Allocate the correct sleeves.

                self.pick_product_fifo(item.id, item.product_id, item.filled_quantity)


            if item.filled_quantity > 0:
                order = ClientOrder.by_id(order.id)
                order.client_order_status_id = self.filled_id
                DBSession.flush()

                #write the history
                self.write_client_order_history(order.id, order.client_order_status_id)

        #update the batch
        self.client_order_batch.client_order_batch_status_id = self.in_process_id
        DBSession.flush()

        self.write_client_order_batch_history(self.in_process_id)

        # Recalculate all the branches now.
        self.recalc_soh(None)
        
        end = timer()
        print("Building this order took: ", end - start)

        adminrole = Role.by_name('Administrator')
        for admin in adminrole.users:
            if not admin.email: continue
            self.send_mail_now('Tanzanite - Automatic Client Branch Order Creation Notification', 
                admin.email, 
                f""" Hi {admin.name},

                An automated order batch for {self.client.name} has been created.

                Please review and complete as needed

                Kind regards,
                The Tanzanite Team
                """ , 
                f""" <html><div><p>
                Hi {admin.name}, <p> </p><p> </p>
                <p> An automated order batch for {self.client.name} has been created. </p> 
                <p> Please review and complete as needed.</p>
                <p> </p> <p> </p> <p>
                Kind regards,
                </p> <p> </p> <p>
                The Tanzanite Team
                </p> 
                </div> </html> """
                )

        return True

    def write_client_order_detail_pack(self, pack_id=None, client_order_detail_id=None, *args, **kwargs):
        if not pack_id or not client_order_detail_id: return None

        this = ClientOrderDetailPack()
        this.client_order_detail_id = client_order_detail_id
        this.packing_detail_id = pack_id
        DBSession.add(this)
        DBSession.flush()
        return this.id

    def get_pack_list_for_order(self, fill_quantity=0, product_id=None, client_reorder_type_id=None, cage_store_location_id=None, *args, **kwargs):
        if not product_id or not client_reorder_type_id or not cage_store_location_id:
            return []
        if fill_quantity == 0: return []
        pack_list = []
        
        raw_pack_list = DBSession.query(PackingDetail). \
            filter(PackingDetail.packing_type_id == client_reorder_type_id). \
            filter(PackingDetail.store_location_id == cage_store_location_id). \
            order_by(func.date(PackingDetail.received),func.lpad(PackingDetail.reference_number,20,' ')).\
            all()
        add_count = 0

        for pack in raw_pack_list:
            supplier_order_detail = SupplierOrderDetail.by_id(pack.supplier_order_detail_id)
            if not supplier_order_detail: continue

            if supplier_order_detail.product_id != product_id: continue
            pack_list.append(pack)
            add_count += 1
            if add_count >= fill_quantity:
                break
            
        return pack_list

    def get_available_packs_in_cage(self, product_id=None, packing_type_id=None, *args, **kwargs):
        if not product_id: return 0

        product = Product.by_id(product_id)
        if not packing_type_id:
            packing_type_id = product.client_reorder_type_id

        raw_count = DBSession.query(ProductStoreLevel). \
                filter(ProductStoreLevel.store_id==self.cage_store_id ). \
                filter(ProductStoreLevel.product_id==product_id). \
                value(func.sum(ProductStoreLevel.quantity))

        if not raw_count:
            raw_count = 0

        if product.client_reorder_type_id == product.level_1_type_id:
            count = (raw_count / product.level_1_quantity)
        elif product.client_reorder_type_id == product.level_2_type_id:
            count = (raw_count / (product.level_1_quantity * product.level_2_quantity))
        elif product.client_reorder_type_id == product.level_3_type_id:
            count = (raw_count / (product.level_1_quantity * product.level_2_quantity * product.level_3_quantity))

        if not count: count = 0
        return count

    def pick_product_fifo(self, client_order_detail_id=None, product_id=None, fill_quantity=None, *args, **kwargs):
        if not client_order_detail_id \
           or not product_id \
           or not fill_quantity:  return False

        product = Product.by_id(product_id)
        client_order_detail = ClientOrderDetail.by_id(client_order_detail_id)
        if not self.cage_store_id or not self.cage_store_location_id:
            #More ordered than are available
            message = 'Cage store location not set up..'
            self.add_audit_log(**{
                'audit_action_id': self.audit_action_id,
                'audit_type_id': self.audit_type_id,
                'key': None,
                'message': message,
            })
            return False

        if not self.outbound_store_location_id:
            #More ordered than are available
            message = 'Outbound stock store location not set up..'
            self.add_audit_log(**{
                'audit_action_id': self.audit_action_id,
                'audit_type_id': self.audit_type_id,
                'key': client_order_detail_id,
                'message': message,
            })
            return False

        pack_Count = self.get_available_packs_in_cage(product_id, product.client_reorder_type_id)

        if fill_quantity > pack_Count:
            #More ordered than are available
            message = 'Insufficient Stock in Cage to fill order.'
            self.add_audit_log(**{
                'audit_action_id': self.audit_action_id,
                'audit_type_id': self.audit_type_id,
                'key': client_order_detail_id,
                'message': message,
            })
            return False

        #TGJ Rewrite...
        #Assumptions: From the existing data, all cards in Bulk and Cage have In Stock status. We may not need to check this.
        pack_list = self.get_pack_list_for_order(fill_quantity, product_id, product.client_reorder_type_id, self.cage_store_location_id)

        if not pack_list:
            #More ordered than are available
            message = 'Error locating FIFO records.'
            self.add_audit_log(**{
                'audit_action_id': self.audit_action_id,
                'audit_type_id': self.audit_type_id,
                'key': client_order_detail_id,
                'message': message,
            })
            return False

        pack_mappings = []
        card_mappings = []
        card_history_mappings = []

        loop_count = 0
        for pack in pack_list:
            loop_count += 1
            self.write_client_order_detail_pack(pack.id, client_order_detail_id)

        if loop_count == 0:
            message = 'Error locating FIFO records.'
            self.add_audit_log(**{
                'audit_action_id': self.audit_action_id,
                'audit_type_id': self.audit_type_id,
                'key': client_order_detail_id,
                'message': message,
            })
            return False

        #change location of the items
        pack_mappings, card_mappings, card_history_mappings = \
            self.card_status_location_change(pack_list, self.outbound_store_location_id, self.picked_id, product_id)

        if pack_mappings:
            DBSession.bulk_update_mappings(PackingDetail, pack_mappings)
        
        if card_mappings:
            DBSession.bulk_update_mappings(Card, card_mappings)

        if card_history_mappings:
            DBSession.bulk_insert_mappings(CardHistory, card_history_mappings)
        DBSession.flush()

        client_order_detail.filled_quantity = fill_quantity
        client_order_detail.filled = datetime.now()
        client_order_detail.filler_by = self.usernow.id
        DBSession.flush()

        # #update store levels cage and outbound/
        # self.update_store_level(product_id, self.cage_store_id)
        # self.update_store_level(product_id, self.outbound_store_location_id)

        message = 'User '+self.usernow.name+' picked '+str(fill_quantity)+' of '+product.description

        self.add_audit_log(**{
            'audit_action_id': self.audit_action_id,
            'audit_type_id': self.audit_type_id,
            'key': client_order_detail_id,
            'message': message,
        })
        return pack_mappings, card_mappings, card_history_mappings

    def enough_stock_in_cage(self, *args, **kwargs):
        if not self.client_order_batch_id: return False
        #Sum the total number of refill qty for each product in this order and see if there is nough stock in Cage...
        dbase_query = DBSession.query(
                        ClientOrderDetail.product_id,
                        func.sum(ClientOrderDetail.order_quantity),
                ). \
            join(ClientOrder, ClientOrder.id == ClientOrderDetail.client_order_id).\
            filter(ClientOrder.client_order_batch_id == self.client_order_batch_id).\
            group_by(ClientOrderDetail.product_id).\
            order_by(ClientOrderDetail.product_id).\
            all()
        if not dbase_query: return False

        for product_id, order_count in dbase_query:
            product = Product.by_id(product_id)
            available = self.get_available_packs_in_cage(product_id, self.cage_store_id, product.client_reorder_type_id)
            if available < order_count: return False

        return True

    def get_client_order_list_to_process(self, *args, **kwargs):
        return DBSession.query(ClientOrder).\
            join(ClientBranch,ClientBranch.id == ClientOrder.client_branch_id).\
            filter(ClientOrder.client_order_batch_id == self.client_order_batch_id).\
            filter(ClientOrder.client_order_status_id != self.filled_id).\
            order_by(asc(func.lpad(ClientBranch.store_number, 10, ' '))). \
            all()

 
#################################################################################
#
# Client Order Cancellation.
#
#################################################################################

class ClientOrderBatchCancellation(ClientOrderClass):
    def __init__(self, client_order_batch_id=None, *args, **kwargs):
        super(ClientOrderBatchCancellation, self).__init__(None, client_order_batch_id, None)
        self.order_cancelled_id = COMMON.get_type_id(ClientOrderStatus, 'Cancelled')
        self.batch_cancelled_id = COMMON.get_type_id(ClientOrderBatchStatus, 'Cancelled')

    def process(self, *args, **kwargs):
        # Pocesses:
        # 1 Select the list of orders for order batch. 
        # 2 Use this list to grab the client order detail list for each order
        # 3 Use this list to grab the client order detail pack list for each order detail
        # 4 Change location of all pakcs and inner packs and cards in this pack record.
        # 5 Delete the client order detail pack record.
        # 6 Make client order detail record filled = 0.
        # 7 Change client order status = cancelled.
        # 8 When all client order records are completed then make client order batch status = cancelled.
        # 9 Recalulate the stock on hand for the necessary store locations
        if not self.client_order_batch_id: return {'success': 'false', }
        if not self.client_order_batch: return {'success': 'false', }
        
        start = timer()
        print('Starting Cancellation:')

        client_order_mappings = []
        client_order_detail_mappings = []
        client_order_history_mappings = []
        
        # 1 Select the list of orders for order batch. 
        client_order_list = ClientOrder.all_by_client_order_batch_id(self.client_order_batch_id)
        
        # DBSession.query(ClientOrder).\
        #     filter(ClientOrder.client_order_batch_id==self.client_order_batch_id).\
        #     all()
        if not client_order_list: return {'success': 'false', }
        for client_order in client_order_list:

            # 2 Use this list to grab the client order detail list for each order
            order_detail_list = ClientOrderDetail.all_by_client_order_id(client_order.id)
            # order_detail_list = self.get_order_detail_list(client_order.id)

            if not order_detail_list: continue

            # 3 Use this list to grab the client order detail pack list for each order detail
            for order_detail in order_detail_list:
                # 4 Change location of all packs and inner packs and cards in this pack record.
                pack_list = self.get_pack_list_from_client_order_detail(order_detail.id)

                #change location of the items
                pack_mappings, card_mappings, card_history_mappings = \
                    self.card_status_location_change(pack_list, self.cage_store_location_id, self.in_stock_id, order_detail.product_id)

                # 5 Delete the client order detail pack record.
                self.remove_client_order_packs(order_detail.id)

                # 6 Make client order detail record filled = 0.
                order_detail_list = DBSession.query(ClientOrderDetail).\
                    filter(ClientOrderDetail.client_order_id==client_order.id).\
                    all()
                for order_detail in order_detail_list:
                    client_order_detail_mappings.append({
                        'id': order_detail.id, 
                        'filled_quantity': 0,
                        'filled': None,
                        'filler_by': None,
                    })

                if pack_mappings:
                    DBSession.bulk_update_mappings(PackingDetail, pack_mappings)
                
                if card_mappings:
                    DBSession.bulk_update_mappings(Card, card_mappings)

                if card_history_mappings:
                    DBSession.bulk_insert_mappings(CardHistory, card_history_mappings)
                DBSession.flush()

            # 7 Change client order status = cancelled.
            client_order_mappings.append({
                'id':client_order.id, 
                'client_order_status_id': self.order_cancelled_id,
                })

            client_order_history_mappings.append({
                'client_order_id' : client_order.id,
                'client_order_status_id' : self.order_cancelled_id,
                'date_time' : datetime.now(),
                'user_id' : self.usernow.id,
                })

        if client_order_mappings:
            DBSession.bulk_update_mappings(ClientOrder, client_order_mappings)
            DBSession.flush()
        if client_order_detail_mappings:
            DBSession.bulk_update_mappings(ClientOrderDetail, client_order_detail_mappings)
            DBSession.flush()
        if client_order_history_mappings:
            DBSession.bulk_insert_mappings(ClientOrderHistory, client_order_history_mappings)
            DBSession.flush()

        # 8 When all client order records are completed then make client order batch status = cancelled.
        self.client_order_batch.client_order_batch_status_id = self.batch_cancelled_id
        self.write_client_order_batch_history(self.batch_cancelled_id)
        DBSession.flush()

        # # 9 Udate the necessary store levels.
        # self.update_store_level(product_id, self.cage_store_id)
        # self.update_store_level(product_id, self.outbound_store_id)

        # 9 Recalulate the stock on hand for the necessary store locations
        #update store levels cage and outbound/
        soh_start = timer()
        # self.recalc_soh(self.outbound_store_location_id)
        # self.recalc_soh(self.cage_store_location_id)
        self.recalc_soh(None)
        soh_end = timer()
        print("Recalc SOH took: ", soh_end - soh_start)

        end = timer()
        print("Completed and it took: ", end - start)
        return {'success': 'true', }

    def get_order_detail_list(self, client_order_id=None, *args, **kwargs):
        return DBSession.query(ClientOrderDetail).\
            filter(ClientOrderDetail.client_order_id==client_order_id).\
            all()

    def remove_client_order_packs(self, client_order_detail_id=None, *args, **kwargs):
        if not client_order_detail_id: return
        DBSession.query(ClientOrderDetailPack). \
            filter(ClientOrderDetailPack.client_order_detail_id == client_order_detail_id).\
            delete()
        # del_list = DBSession.query(ClientOrderDetailPack). \
        #     filter(ClientOrderDetailPack.client_order_detail_id == client_order_detail_id). \
        #     all()
        # #delete these records.
        # for item in del_list:
        #     DBSession.delete(item)
        DBSession.flush()
        return

    def remove_filled_quantity(self, client_order_detail=None, *args, **kwargs):
        if not client_order_detail: return
        client_order_detail.filled_quantity = 0
        client_order_detail.filled = None
        client_order_detail.filler_by = None
        DBSession.flush()
        return

    def change_client_order_status(self, client_order=None, *args, **kwargs):
        if not client_order: return
        count = self.check_all_filled(client_order.id)
        if count:
            new_status_id = client_order.client_order_status_id
            if client_order.client_order_status_id == self.shipped_id:
                new_status_id = self.orderd_id
            elif client_order.client_order_status_id == self.filled_id:
                new_status_id = self.orderd_id
            client_order.client_order_status_id = new_status_id
            DBSession.flush()


#################################################################################
#
# Client Order Cancellation.
#
#################################################################################

class ShipClientOrderBatch(ClientOrderClass):
    def __init__(self, client_order_batch_id=None, *args, **kwargs):
        super(ShipClientOrderBatch, self).__init__(None, client_order_batch_id, None)
        self.batch_completed_status_is = COMMON.get_type_id(ClientOrderBatchStatus, 'Complete')

    def process(self, *args, **kwargs):
        start = timer()
        print('Starting Shipping: ')
        if self.client_order_batch.client_order_batch_status_id != self.in_process_id:
            batch_status = COMMON.get_type_label(ClientOrderBatchStatus, self.client_order_batch.client_order_batch_status_id)
            return json.dumps({'success': 'false', 'message':'Order status is '+batch_status+' and cannot be shipped.',})

        #The Courier References are already populated by the time this is called.
        dbase_query = DBSession.query(ClientOrder).\
            filter(ClientOrder.client_order_batch_id == self.client_order_batch_id).\
            order_by(asc(ClientOrder.order_number)).\
            all()
        for order in dbase_query:
            self.client_order_branch_ship(order)

        self.client_order_batch.client_order_batch_status_id = self.batch_completed_status_is
        DBSession.flush()

        # Recalculate all the branches now.
        self.recalc_soh(None)
        end = timer()
        print("Shipping this order took: ", end - start)

        return json.dumps({'success': 'true', })

    def client_order_branch_ship(self, client_order=None, *args, **kwargs):
        if not client_order: return False

        dbase_query = DBSession.query(ClientOrderDetail, Product). \
            filter(ClientOrderDetail.product_id == Product.id).\
            filter(ClientOrderDetail.client_order_id == client_order.id). \
            order_by(asc(ClientOrderDetail.id)). \
            all()

        this_pack_mappings = []
        this_card_mappings = []
        this_card_history_mappings = []

        #These for loops need to be put in methods!!!!!
        for item, product in dbase_query:
            client_branch = ClientBranch.by_id(client_order.client_branch_id)
            store = Store.by_branch_id(client_branch.id)
            store_location = StoreLocation.by_store_id(store.id)

            pack_list = self.get_pack_list_from_client_order_detail(item.id)

            # print('#############################################################################################')
            # print('TGJ: Todo: THIS IS TOO SLOW client_order_branch_ship 2')
            # print('TGJ: Todo: redo this logic........')
            # print('#############################################################################################')

            #change location of the items
            pack_mappings, card_mappings, card_history_mappings = \
                self.card_status_location_change(pack_list, store_location.id, self.in_stock_id, product.id)

            this_pack_mappings.extend(pack_mappings)
            this_card_mappings.extend(card_mappings)
            this_card_history_mappings.extend(card_history_mappings)

        if this_pack_mappings:
            DBSession.bulk_update_mappings(PackingDetail, this_pack_mappings)
        
        if this_card_mappings:
            DBSession.bulk_update_mappings(Card, this_card_mappings)

        if this_card_history_mappings:
            DBSession.bulk_insert_mappings(CardHistory, this_card_history_mappings)
        DBSession.flush()

        client_order.client_order_status_id = self.shipped_id
        DBSession.flush()

        #write the history
        self.write_client_order_history(client_order.id, client_order.client_order_status_id)

        self.add_audit_log(**{
            'audit_action_id': self.audit_action_id,
            'audit_type_id': self.audit_type_id,
            'key': client_order.id,
            'message': 'User '+self.usernow.name +' Shipped Order '+client_order.order_number,
        })

        return json.dumps({'success':'true'})



