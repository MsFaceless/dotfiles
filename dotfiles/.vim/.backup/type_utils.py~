# -*- coding: utf-8 -*-
from sqlalchemy.exc import IntegrityError
from rocket import model
import transaction
import traceback
import logging

log = logging.getLogger(__name__)

class RawTypeDictionary:
    def __init__(self):
        self.__list_of_type_dicts = [
            # """Entity Types"""
            {
                "entity_type": {"person", "organisation"},

                "entity_address_type": {"street", "postal"},
                "entity_bank_account_type": {"commercial", "investment", "wallet"},
                "entity_contact_type": {"mobile", "email", "facsimile"},

                "entity_organisation_type": {"private company", "public company", "trust", "closed corporation"},

                "entity_person_gender_type": {"male", "female", "other", "unknown"},
                "entity_person_marital_status_type": {"married", "single"},
                "entity_person_identity_type": {"identity_number", "passport_number", "other", "unknown", "mobile"},
            },

            {
                # """Shared: Product & Benefit Types"""
                "communication_type": {"sms", "email", "print"},
                "period_type": {"days", "months", "calendar_months", "years"},
                "loader_question_premium_effect_type": {"none", "percentage", "amount"},

                # """Product Types"""
                "product_type": {"group", "voucher", "contractual"},
                "product_message_type": {"reminder", "confirmation"},
                "product_state_type": {"sandbox", "active", "expired"},

                # """Benefit Types"""
                "benefit_message_type": {"claim", "refund"},
                "benefit_purchase_type": {"group", "individual", "coupon", "loyalty"},
                "benefit_price_type": {"fixed", "rate_table"},
                "benefit_insured_type": {"business", "natural_person", "member_only", "member_and_family", "family_only"},
                "benefit_exclusion_expiry_type": {"number_of_days", "number_of_premiums", "infinite"},
                "benefit_period_effect_type": {"active", "waiting", "claim_grace", "refund_grace"},
                "benefit_allocation_calculation_type": {"percentage", "amount", "factor"},
                "benefit_allocation_type": {"claim", "redemption", "refund", "acquisition", "purchase"},
                "benefit_insured_life_relationship_type": {"principal", "spouse", "child", "parent", "grand_parent", "extended_family", "household"},
                "benefit_asset_type": {"business", "employee", "property", "vehicle", "landlord"},
            },
            # """Policy Types"""
            {
                "policy_status_type": {"pre_quote", "not_taken_up", "rejected", "quote", "surrendered", "matured", "claimed", "lapsed", "active", "accepted", "issued", "in force"},
                "policy_date_type": {"proposal", "accepted", "policy", "valid_from", "valid_to", "surrender", "maturity", "purchase_date"},
                "policy_premium_due_on_type": {"first_day_of_the_month", "last_day_of_the_month"},
                "policy_benefit_status_type": {"expired", "active", "fully_claimed"},
                "policy_benefit_insured_asset_ownership_type": {"shared", "leased", "full_ownership"},
                "policy_benefit_insured_asset_vehicle_insured_type": {"insured", "uninsured", "third_party"}
            },

            # """Transaction Types"""
            {
                # Premiums
                "premium_due_settlement_state_type": {"fully_settled", "partially_settled", "awaiting_settlement"},
                "premium_due_payment_type": {"final", "partial", "reversal"},
                "premium_due_payment_state_type": {"pending", "success", "failed"},
                "premium_due_payment_state_failed_type": {"transaction_failed", "transaction_cancelled"},

                # Transactions
                "transaction_type": {"reversal", "payment_made", "payment_received"},
                "transaction_state_type": {"pending", "processed", "failed"},
                "transaction_distribution_type": {"premium", "claim"},
                "payment_received_type": {"debit_order", "eft", "cash"},
                "transaction_state_failed_type": {"incorrect_banking_details"},

                # Debit Orders
                "payment_provider_documentation_type": {"test1", "test2"},  # TODO need types
                "debit_order_run_state_type": {"completed", "pre_collection", "collection", "lead", "in_progress"},  # TODO need more types
                "debit_order_run_file_type": {"collection_file"},
            },

            # """ Claim Types """
            {
                "claim_status_type": {"registered", "rejected", "suspended", "ready_for_approval", "approved", "adjudicated", "reopened", "completed", "repudiated"},
            },

            # """Batch Import Types"""
            {
                'batch_import_type': {'member', 'purchase', 'family'},
            },

            # """ Utilities Types
            {
                "system_document_type": {"welcome", "claim", "member", "product"},
                "mail_option_type": {"print", "email", "download"},
                "message_batch_type": {"none", "spreadsheet", "other"},
                "billing_frequency_type": {"daily", "weekly", "monthly", "quarterly", "bi_annually", "annually"},
                "frequency_type": {"single", "daily", "monthly", "semi_annually", "annually"},
                "system_parameter_data_type": {"link", "integer", "boolean"},
            },
            # """ Document Management System (DMS) Types
            {
                "file_type": {"image", "document", "audio", "video", "archive", "file"},
                "mime_parent_type": {"application", "audio", "font", "image", "message", "text", "video", "x-world"},
            },
            # """ Campaigns Types
            {
                "campaign_state_type": {"Active", "Terminated", "Suspended"},
            },
            # """ Leads Types
            {
                "lead_type": {"lead_type_1", "lead_type_2"},
                "lead_status_type": {"new", "in_process", "duplicated", "completed"},
                "lead_contact_type": {"msisdn", "identity_number", "email_address"},
            },
            # """ Appointment Types
            {
                "appointment_duration_type": {"future_appointment", "walk_in", "busy_with_work", "personal_/_leave", "birthday"},
                "appointment_status_type": {"waiting", "started", "finished", "no_show"},
                "day_of_week_type": {"monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"},
            },

            # """ Call Center Types
            {
                "call_status_type": {"completed", "no answer", "busy", "failed", "ringing",  "cancelled", "undialed"},
                "task_order_type": {"first in, first out",  "last in, first out"},
                "task_status_type" : {"pending", "cancelled", "assigned",  "completed" },

            },
        ]
        self.raw_dictionary_of_types = self.__create_raw_dict_of_types()

    def __create_raw_dict_of_types(self):
        dict_types = {}
        for dictionary in self.__list_of_type_dicts:
            dict_types.update(dictionary)
        return dict_types

raw_type_dictionary = RawTypeDictionary().raw_dictionary_of_types

def create_type_tables(DBSession=None, dict_of_types={}):
    if not DBSession or not dict_of_types:
        return False
    for i in dict_of_types:

        item = dict_of_types.get(i)
        class_name = i.title().replace("_", "")
        classobj = getattr(model, class_name)

        for primary_key, raw_name in enumerate(item, start=1):

            pretty_name = raw_name.lower().replace(" ", "_")
            exists = classobj().by_attr_first('name', pretty_name)
            if not exists:
                exists = classobj().by_attr_first('id', primary_key)
            if not exists:
                this = classobj()
                this.id = primary_key
                this.name = pretty_name
                DBSession.add(this)
                DBSession.flush()
                #print("CREATING", class_name, this, pretty_name)
            else:
                #print("SKIPPING", class_name, exists, pretty_name)
                pass

        transaction.commit()
    return True

def create_type_tablesOLD(DBSession=None, dict_of_types={}):
    if not dict_of_types: return False
    if not DBSession: return False
    for i in dict_of_types:
        type_class = i.title().replace("_", "")
        try:
            list_of_dicts = []
            for y, value in enumerate(sorted(dict_of_types.get(i)), 1):
                list_of_dicts.append(
                    getattr(model, type_class)(id=y, name=value.lower().replace(" ", "_"))
                )
            DBSession.add_all(list_of_dicts)
            try:
                DBSession.flush()
            except Exception as e:
                log.warning(f"Warning, {e}")
                pass
            transaction.commit()
        except IntegrityError:
            error_title = i.capitalize().replace("_", " ")
            log.info(f"Warning, there was a problem adding LIST OF {error_title}S, it may have already been added.")
            log.info(traceback.format_exc())
            transaction.abort()
            log.info('Continuing with bootstrapping...')

class TypeDictionary:
    def __init__(self):
        self.list_of_types = list(raw_type_dictionary)
        self.type_dictionary = self.__create_type_dictionary_from_database()

    def __create_type_dictionary_from_database(self):
        type_dict = {}
        for i in self.list_of_types:
            class_name = i.title().replace("_", "")
            classobj = getattr(model, class_name)
            dbase_query = classobj().get_all('name')
            type_dict.update({i: {i.id: i.name for i in dbase_query}})
        return type_dict

    def get_id_of_name(self, type_table_name: str, type_name: str):
        sub_dict = self.type_dictionary.get(type_table_name)
        if not sub_dict:
            log.info(f"\n > get_id_of_name: No such type found: {type_table_name} < \n")
            return None
        for key, value in sub_dict.items():
            if value == type_name:
                return key
        log.info(f"\n > get_id_of_name: No such name found: {type_table_name} - {type_name} < \n")
        return None

    def get_pretty_name(self, type_table_name: str, type_id: int):
        sub_dict = self.type_dictionary.get(type_table_name)
        if not sub_dict:
            log.info(f"\n > get_pretty_name: No such type found: {type_table_name} < \n")
            return None
        for key, value in sub_dict.items():
            if key == type_id:
                return value.title().replace("_", " ")
        log.info(f"\n > get_pretty_name: No such id found: {type_table_name} - {type_id} < \n")
        return None

    def get_name(self, type_table_name: str, type_id: int):
        sub_dict = self.type_dictionary.get(type_table_name)
        if not sub_dict:
            log.info(f"\n > get_name: No such type found: {type_table_name} < \n")
            return None
        for key, value in sub_dict.items():
            if key == int(type_id):
                return value
        log.info(f"\n > get_name: No such id found: {type_table_name} - {type_id} < \n")
        return None

    def get_dict_of_types(self, type_table_name: str):
        sub_dict = self.type_dictionary.get(type_table_name)
        if not sub_dict:
            log.info(f"\n > get_dict_of_types: No such type found: {type_table_name} < \n")
            return None
        return sub_dict
